// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dialogs.proto

#ifndef PROTOBUF_dialogs_2eproto__INCLUDED
#define PROTOBUF_dialogs_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "messaging_base.pb.h"
#include "group_base.pb.h"
#include "peers.pb.h"
#include "users.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_dialogs_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[23];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsDialogImpl();
void InitDefaultsDialog();
void InitDefaultsLoadDialogsReqImpl();
void InitDefaultsLoadDialogsReq();
void InitDefaultsLoadDialogsRspImpl();
void InitDefaultsLoadDialogsRsp();
void InitDefaultsCreateChatDialogReqImpl();
void InitDefaultsCreateChatDialogReq();
void InitDefaultsCreateChatDialogRspImpl();
void InitDefaultsCreateChatDialogRsp();
void InitDefaultsBlockPeerReqImpl();
void InitDefaultsBlockPeerReq();
void InitDefaultsUnblockPeerReqImpl();
void InitDefaultsUnblockPeerReq();
void InitDefaultsTopPeerReqImpl();
void InitDefaultsTopPeerReq();
void InitDefaultsUntopPeerReqImpl();
void InitDefaultsUntopPeerReq();
void InitDefaultsDndPeerReqImpl();
void InitDefaultsDndPeerReq();
void InitDefaultsUndndPeerReqImpl();
void InitDefaultsUndndPeerReq();
void InitDefaultsLoadBlockedPeersReqImpl();
void InitDefaultsLoadBlockedPeersReq();
void InitDefaultsLoadBlockedPeersRspImpl();
void InitDefaultsLoadBlockedPeersRsp();
void InitDefaultsLoadTopedPeersReqImpl();
void InitDefaultsLoadTopedPeersReq();
void InitDefaultsLoadTopedPeersRspImpl();
void InitDefaultsLoadTopedPeersRsp();
void InitDefaultsLoadDndedPeersReqImpl();
void InitDefaultsLoadDndedPeersReq();
void InitDefaultsLoadDndedPeersRspImpl();
void InitDefaultsLoadDndedPeersRsp();
void InitDefaultsPeerBlockedNotifyImpl();
void InitDefaultsPeerBlockedNotify();
void InitDefaultsPeerUnblockedNotifyImpl();
void InitDefaultsPeerUnblockedNotify();
void InitDefaultsPeerTopedNotifyImpl();
void InitDefaultsPeerTopedNotify();
void InitDefaultsPeerUntopedNotifyImpl();
void InitDefaultsPeerUntopedNotify();
void InitDefaultsPeerDndedNotifyImpl();
void InitDefaultsPeerDndedNotify();
void InitDefaultsPeerUndndedNotifyImpl();
void InitDefaultsPeerUndndedNotify();
inline void InitDefaults() {
  InitDefaultsDialog();
  InitDefaultsLoadDialogsReq();
  InitDefaultsLoadDialogsRsp();
  InitDefaultsCreateChatDialogReq();
  InitDefaultsCreateChatDialogRsp();
  InitDefaultsBlockPeerReq();
  InitDefaultsUnblockPeerReq();
  InitDefaultsTopPeerReq();
  InitDefaultsUntopPeerReq();
  InitDefaultsDndPeerReq();
  InitDefaultsUndndPeerReq();
  InitDefaultsLoadBlockedPeersReq();
  InitDefaultsLoadBlockedPeersRsp();
  InitDefaultsLoadTopedPeersReq();
  InitDefaultsLoadTopedPeersRsp();
  InitDefaultsLoadDndedPeersReq();
  InitDefaultsLoadDndedPeersRsp();
  InitDefaultsPeerBlockedNotify();
  InitDefaultsPeerUnblockedNotify();
  InitDefaultsPeerTopedNotify();
  InitDefaultsPeerUntopedNotify();
  InitDefaultsPeerDndedNotify();
  InitDefaultsPeerUndndedNotify();
}
}  // namespace protobuf_dialogs_2eproto
namespace zproto {
class BlockPeerReq;
class BlockPeerReqDefaultTypeInternal;
extern BlockPeerReqDefaultTypeInternal _BlockPeerReq_default_instance_;
class CreateChatDialogReq;
class CreateChatDialogReqDefaultTypeInternal;
extern CreateChatDialogReqDefaultTypeInternal _CreateChatDialogReq_default_instance_;
class CreateChatDialogRsp;
class CreateChatDialogRspDefaultTypeInternal;
extern CreateChatDialogRspDefaultTypeInternal _CreateChatDialogRsp_default_instance_;
class Dialog;
class DialogDefaultTypeInternal;
extern DialogDefaultTypeInternal _Dialog_default_instance_;
class DndPeerReq;
class DndPeerReqDefaultTypeInternal;
extern DndPeerReqDefaultTypeInternal _DndPeerReq_default_instance_;
class LoadBlockedPeersReq;
class LoadBlockedPeersReqDefaultTypeInternal;
extern LoadBlockedPeersReqDefaultTypeInternal _LoadBlockedPeersReq_default_instance_;
class LoadBlockedPeersRsp;
class LoadBlockedPeersRspDefaultTypeInternal;
extern LoadBlockedPeersRspDefaultTypeInternal _LoadBlockedPeersRsp_default_instance_;
class LoadDialogsReq;
class LoadDialogsReqDefaultTypeInternal;
extern LoadDialogsReqDefaultTypeInternal _LoadDialogsReq_default_instance_;
class LoadDialogsRsp;
class LoadDialogsRspDefaultTypeInternal;
extern LoadDialogsRspDefaultTypeInternal _LoadDialogsRsp_default_instance_;
class LoadDndedPeersReq;
class LoadDndedPeersReqDefaultTypeInternal;
extern LoadDndedPeersReqDefaultTypeInternal _LoadDndedPeersReq_default_instance_;
class LoadDndedPeersRsp;
class LoadDndedPeersRspDefaultTypeInternal;
extern LoadDndedPeersRspDefaultTypeInternal _LoadDndedPeersRsp_default_instance_;
class LoadTopedPeersReq;
class LoadTopedPeersReqDefaultTypeInternal;
extern LoadTopedPeersReqDefaultTypeInternal _LoadTopedPeersReq_default_instance_;
class LoadTopedPeersRsp;
class LoadTopedPeersRspDefaultTypeInternal;
extern LoadTopedPeersRspDefaultTypeInternal _LoadTopedPeersRsp_default_instance_;
class PeerBlockedNotify;
class PeerBlockedNotifyDefaultTypeInternal;
extern PeerBlockedNotifyDefaultTypeInternal _PeerBlockedNotify_default_instance_;
class PeerDndedNotify;
class PeerDndedNotifyDefaultTypeInternal;
extern PeerDndedNotifyDefaultTypeInternal _PeerDndedNotify_default_instance_;
class PeerTopedNotify;
class PeerTopedNotifyDefaultTypeInternal;
extern PeerTopedNotifyDefaultTypeInternal _PeerTopedNotify_default_instance_;
class PeerUnblockedNotify;
class PeerUnblockedNotifyDefaultTypeInternal;
extern PeerUnblockedNotifyDefaultTypeInternal _PeerUnblockedNotify_default_instance_;
class PeerUndndedNotify;
class PeerUndndedNotifyDefaultTypeInternal;
extern PeerUndndedNotifyDefaultTypeInternal _PeerUndndedNotify_default_instance_;
class PeerUntopedNotify;
class PeerUntopedNotifyDefaultTypeInternal;
extern PeerUntopedNotifyDefaultTypeInternal _PeerUntopedNotify_default_instance_;
class TopPeerReq;
class TopPeerReqDefaultTypeInternal;
extern TopPeerReqDefaultTypeInternal _TopPeerReq_default_instance_;
class UnblockPeerReq;
class UnblockPeerReqDefaultTypeInternal;
extern UnblockPeerReqDefaultTypeInternal _UnblockPeerReq_default_instance_;
class UndndPeerReq;
class UndndPeerReqDefaultTypeInternal;
extern UndndPeerReqDefaultTypeInternal _UndndPeerReq_default_instance_;
class UntopPeerReq;
class UntopPeerReqDefaultTypeInternal;
extern UntopPeerReqDefaultTypeInternal _UntopPeerReq_default_instance_;
}  // namespace zproto
namespace zproto {

// ===================================================================

class Dialog : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zproto.Dialog) */ {
 public:
  Dialog();
  virtual ~Dialog();

  Dialog(const Dialog& from);

  inline Dialog& operator=(const Dialog& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Dialog(Dialog&& from) noexcept
    : Dialog() {
    *this = ::std::move(from);
  }

  inline Dialog& operator=(Dialog&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Dialog& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Dialog* internal_default_instance() {
    return reinterpret_cast<const Dialog*>(
               &_Dialog_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Dialog* other);
  friend void swap(Dialog& a, Dialog& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Dialog* New() const PROTOBUF_FINAL { return New(NULL); }

  Dialog* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Dialog* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .zproto.Peer peer = 1;
  bool has_peer() const;
  void clear_peer();
  static const int kPeerFieldNumber = 1;
  const ::zproto::Peer& peer() const;
  ::zproto::Peer* release_peer();
  ::zproto::Peer* mutable_peer();
  void set_allocated_peer(::zproto::Peer* peer);

  // .zproto.MessageContainer last_message = 4;
  bool has_last_message() const;
  void clear_last_message();
  static const int kLastMessageFieldNumber = 4;
  const ::zproto::MessageContainer& last_message() const;
  ::zproto::MessageContainer* release_last_message();
  ::zproto::MessageContainer* mutable_last_message();
  void set_allocated_last_message(::zproto::MessageContainer* last_message);

  // int64 sort_date = 3;
  void clear_sort_date();
  static const int kSortDateFieldNumber = 3;
  ::google::protobuf::int64 sort_date() const;
  void set_sort_date(::google::protobuf::int64 value);

  // int64 first_unread_date = 5;
  void clear_first_unread_date();
  static const int kFirstUnreadDateFieldNumber = 5;
  ::google::protobuf::int64 first_unread_date() const;
  void set_first_unread_date(::google::protobuf::int64 value);

  // int32 unread_count = 2;
  void clear_unread_count();
  static const int kUnreadCountFieldNumber = 2;
  ::google::protobuf::int32 unread_count() const;
  void set_unread_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:zproto.Dialog)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::zproto::Peer* peer_;
  ::zproto::MessageContainer* last_message_;
  ::google::protobuf::int64 sort_date_;
  ::google::protobuf::int64 first_unread_date_;
  ::google::protobuf::int32 unread_count_;
  mutable int _cached_size_;
  friend struct ::protobuf_dialogs_2eproto::TableStruct;
  friend void ::protobuf_dialogs_2eproto::InitDefaultsDialogImpl();
};
// -------------------------------------------------------------------

class LoadDialogsReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zproto.LoadDialogsReq) */ {
 public:
  LoadDialogsReq();
  virtual ~LoadDialogsReq();

  LoadDialogsReq(const LoadDialogsReq& from);

  inline LoadDialogsReq& operator=(const LoadDialogsReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoadDialogsReq(LoadDialogsReq&& from) noexcept
    : LoadDialogsReq() {
    *this = ::std::move(from);
  }

  inline LoadDialogsReq& operator=(LoadDialogsReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoadDialogsReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoadDialogsReq* internal_default_instance() {
    return reinterpret_cast<const LoadDialogsReq*>(
               &_LoadDialogsReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(LoadDialogsReq* other);
  friend void swap(LoadDialogsReq& a, LoadDialogsReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoadDialogsReq* New() const PROTOBUF_FINAL { return New(NULL); }

  LoadDialogsReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LoadDialogsReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 min_date = 1;
  void clear_min_date();
  static const int kMinDateFieldNumber = 1;
  ::google::protobuf::int64 min_date() const;
  void set_min_date(::google::protobuf::int64 value);

  // .zproto.ListLoadMode load_mode = 2;
  void clear_load_mode();
  static const int kLoadModeFieldNumber = 2;
  ::zproto::ListLoadMode load_mode() const;
  void set_load_mode(::zproto::ListLoadMode value);

  // int32 limit = 3;
  void clear_limit();
  static const int kLimitFieldNumber = 3;
  ::google::protobuf::int32 limit() const;
  void set_limit(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:zproto.LoadDialogsReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 min_date_;
  int load_mode_;
  ::google::protobuf::int32 limit_;
  mutable int _cached_size_;
  friend struct ::protobuf_dialogs_2eproto::TableStruct;
  friend void ::protobuf_dialogs_2eproto::InitDefaultsLoadDialogsReqImpl();
};
// -------------------------------------------------------------------

class LoadDialogsRsp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zproto.LoadDialogsRsp) */ {
 public:
  LoadDialogsRsp();
  virtual ~LoadDialogsRsp();

  LoadDialogsRsp(const LoadDialogsRsp& from);

  inline LoadDialogsRsp& operator=(const LoadDialogsRsp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoadDialogsRsp(LoadDialogsRsp&& from) noexcept
    : LoadDialogsRsp() {
    *this = ::std::move(from);
  }

  inline LoadDialogsRsp& operator=(LoadDialogsRsp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoadDialogsRsp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoadDialogsRsp* internal_default_instance() {
    return reinterpret_cast<const LoadDialogsRsp*>(
               &_LoadDialogsRsp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(LoadDialogsRsp* other);
  friend void swap(LoadDialogsRsp& a, LoadDialogsRsp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoadDialogsRsp* New() const PROTOBUF_FINAL { return New(NULL); }

  LoadDialogsRsp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LoadDialogsRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .zproto.Group groups = 1;
  int groups_size() const;
  void clear_groups();
  static const int kGroupsFieldNumber = 1;
  const ::zproto::Group& groups(int index) const;
  ::zproto::Group* mutable_groups(int index);
  ::zproto::Group* add_groups();
  ::google::protobuf::RepeatedPtrField< ::zproto::Group >*
      mutable_groups();
  const ::google::protobuf::RepeatedPtrField< ::zproto::Group >&
      groups() const;

  // repeated .zproto.User users = 2;
  int users_size() const;
  void clear_users();
  static const int kUsersFieldNumber = 2;
  const ::zproto::User& users(int index) const;
  ::zproto::User* mutable_users(int index);
  ::zproto::User* add_users();
  ::google::protobuf::RepeatedPtrField< ::zproto::User >*
      mutable_users();
  const ::google::protobuf::RepeatedPtrField< ::zproto::User >&
      users() const;

  // repeated .zproto.Dialog dialogs = 3;
  int dialogs_size() const;
  void clear_dialogs();
  static const int kDialogsFieldNumber = 3;
  const ::zproto::Dialog& dialogs(int index) const;
  ::zproto::Dialog* mutable_dialogs(int index);
  ::zproto::Dialog* add_dialogs();
  ::google::protobuf::RepeatedPtrField< ::zproto::Dialog >*
      mutable_dialogs();
  const ::google::protobuf::RepeatedPtrField< ::zproto::Dialog >&
      dialogs() const;

  // repeated .zproto.UserOutPeer user_peers = 4;
  int user_peers_size() const;
  void clear_user_peers();
  static const int kUserPeersFieldNumber = 4;
  const ::zproto::UserOutPeer& user_peers(int index) const;
  ::zproto::UserOutPeer* mutable_user_peers(int index);
  ::zproto::UserOutPeer* add_user_peers();
  ::google::protobuf::RepeatedPtrField< ::zproto::UserOutPeer >*
      mutable_user_peers();
  const ::google::protobuf::RepeatedPtrField< ::zproto::UserOutPeer >&
      user_peers() const;

  // repeated .zproto.GroupOutPeer group_peers = 5;
  int group_peers_size() const;
  void clear_group_peers();
  static const int kGroupPeersFieldNumber = 5;
  const ::zproto::GroupOutPeer& group_peers(int index) const;
  ::zproto::GroupOutPeer* mutable_group_peers(int index);
  ::zproto::GroupOutPeer* add_group_peers();
  ::google::protobuf::RepeatedPtrField< ::zproto::GroupOutPeer >*
      mutable_group_peers();
  const ::google::protobuf::RepeatedPtrField< ::zproto::GroupOutPeer >&
      group_peers() const;

  // @@protoc_insertion_point(class_scope:zproto.LoadDialogsRsp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::zproto::Group > groups_;
  ::google::protobuf::RepeatedPtrField< ::zproto::User > users_;
  ::google::protobuf::RepeatedPtrField< ::zproto::Dialog > dialogs_;
  ::google::protobuf::RepeatedPtrField< ::zproto::UserOutPeer > user_peers_;
  ::google::protobuf::RepeatedPtrField< ::zproto::GroupOutPeer > group_peers_;
  mutable int _cached_size_;
  friend struct ::protobuf_dialogs_2eproto::TableStruct;
  friend void ::protobuf_dialogs_2eproto::InitDefaultsLoadDialogsRspImpl();
};
// -------------------------------------------------------------------

class CreateChatDialogReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zproto.CreateChatDialogReq) */ {
 public:
  CreateChatDialogReq();
  virtual ~CreateChatDialogReq();

  CreateChatDialogReq(const CreateChatDialogReq& from);

  inline CreateChatDialogReq& operator=(const CreateChatDialogReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateChatDialogReq(CreateChatDialogReq&& from) noexcept
    : CreateChatDialogReq() {
    *this = ::std::move(from);
  }

  inline CreateChatDialogReq& operator=(CreateChatDialogReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateChatDialogReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateChatDialogReq* internal_default_instance() {
    return reinterpret_cast<const CreateChatDialogReq*>(
               &_CreateChatDialogReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(CreateChatDialogReq* other);
  friend void swap(CreateChatDialogReq& a, CreateChatDialogReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateChatDialogReq* New() const PROTOBUF_FINAL { return New(NULL); }

  CreateChatDialogReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CreateChatDialogReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string peer_id = 1;
  void clear_peer_id();
  static const int kPeerIdFieldNumber = 1;
  const ::std::string& peer_id() const;
  void set_peer_id(const ::std::string& value);
  #if LANG_CXX11
  void set_peer_id(::std::string&& value);
  #endif
  void set_peer_id(const char* value);
  void set_peer_id(const char* value, size_t size);
  ::std::string* mutable_peer_id();
  ::std::string* release_peer_id();
  void set_allocated_peer_id(::std::string* peer_id);

  // @@protoc_insertion_point(class_scope:zproto.CreateChatDialogReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr peer_id_;
  mutable int _cached_size_;
  friend struct ::protobuf_dialogs_2eproto::TableStruct;
  friend void ::protobuf_dialogs_2eproto::InitDefaultsCreateChatDialogReqImpl();
};
// -------------------------------------------------------------------

class CreateChatDialogRsp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zproto.CreateChatDialogRsp) */ {
 public:
  CreateChatDialogRsp();
  virtual ~CreateChatDialogRsp();

  CreateChatDialogRsp(const CreateChatDialogRsp& from);

  inline CreateChatDialogRsp& operator=(const CreateChatDialogRsp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateChatDialogRsp(CreateChatDialogRsp&& from) noexcept
    : CreateChatDialogRsp() {
    *this = ::std::move(from);
  }

  inline CreateChatDialogRsp& operator=(CreateChatDialogRsp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateChatDialogRsp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateChatDialogRsp* internal_default_instance() {
    return reinterpret_cast<const CreateChatDialogRsp*>(
               &_CreateChatDialogRsp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(CreateChatDialogRsp* other);
  friend void swap(CreateChatDialogRsp& a, CreateChatDialogRsp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateChatDialogRsp* New() const PROTOBUF_FINAL { return New(NULL); }

  CreateChatDialogRsp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CreateChatDialogRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .zproto.OutPeer peer = 1;
  bool has_peer() const;
  void clear_peer();
  static const int kPeerFieldNumber = 1;
  const ::zproto::OutPeer& peer() const;
  ::zproto::OutPeer* release_peer();
  ::zproto::OutPeer* mutable_peer();
  void set_allocated_peer(::zproto::OutPeer* peer);

  // @@protoc_insertion_point(class_scope:zproto.CreateChatDialogRsp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::zproto::OutPeer* peer_;
  mutable int _cached_size_;
  friend struct ::protobuf_dialogs_2eproto::TableStruct;
  friend void ::protobuf_dialogs_2eproto::InitDefaultsCreateChatDialogRspImpl();
};
// -------------------------------------------------------------------

class BlockPeerReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zproto.BlockPeerReq) */ {
 public:
  BlockPeerReq();
  virtual ~BlockPeerReq();

  BlockPeerReq(const BlockPeerReq& from);

  inline BlockPeerReq& operator=(const BlockPeerReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BlockPeerReq(BlockPeerReq&& from) noexcept
    : BlockPeerReq() {
    *this = ::std::move(from);
  }

  inline BlockPeerReq& operator=(BlockPeerReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BlockPeerReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BlockPeerReq* internal_default_instance() {
    return reinterpret_cast<const BlockPeerReq*>(
               &_BlockPeerReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(BlockPeerReq* other);
  friend void swap(BlockPeerReq& a, BlockPeerReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BlockPeerReq* New() const PROTOBUF_FINAL { return New(NULL); }

  BlockPeerReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BlockPeerReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .zproto.OutPeer peer = 1;
  bool has_peer() const;
  void clear_peer();
  static const int kPeerFieldNumber = 1;
  const ::zproto::OutPeer& peer() const;
  ::zproto::OutPeer* release_peer();
  ::zproto::OutPeer* mutable_peer();
  void set_allocated_peer(::zproto::OutPeer* peer);

  // @@protoc_insertion_point(class_scope:zproto.BlockPeerReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::zproto::OutPeer* peer_;
  mutable int _cached_size_;
  friend struct ::protobuf_dialogs_2eproto::TableStruct;
  friend void ::protobuf_dialogs_2eproto::InitDefaultsBlockPeerReqImpl();
};
// -------------------------------------------------------------------

class UnblockPeerReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zproto.UnblockPeerReq) */ {
 public:
  UnblockPeerReq();
  virtual ~UnblockPeerReq();

  UnblockPeerReq(const UnblockPeerReq& from);

  inline UnblockPeerReq& operator=(const UnblockPeerReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UnblockPeerReq(UnblockPeerReq&& from) noexcept
    : UnblockPeerReq() {
    *this = ::std::move(from);
  }

  inline UnblockPeerReq& operator=(UnblockPeerReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UnblockPeerReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnblockPeerReq* internal_default_instance() {
    return reinterpret_cast<const UnblockPeerReq*>(
               &_UnblockPeerReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(UnblockPeerReq* other);
  friend void swap(UnblockPeerReq& a, UnblockPeerReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UnblockPeerReq* New() const PROTOBUF_FINAL { return New(NULL); }

  UnblockPeerReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UnblockPeerReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .zproto.OutPeer peer = 1;
  bool has_peer() const;
  void clear_peer();
  static const int kPeerFieldNumber = 1;
  const ::zproto::OutPeer& peer() const;
  ::zproto::OutPeer* release_peer();
  ::zproto::OutPeer* mutable_peer();
  void set_allocated_peer(::zproto::OutPeer* peer);

  // @@protoc_insertion_point(class_scope:zproto.UnblockPeerReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::zproto::OutPeer* peer_;
  mutable int _cached_size_;
  friend struct ::protobuf_dialogs_2eproto::TableStruct;
  friend void ::protobuf_dialogs_2eproto::InitDefaultsUnblockPeerReqImpl();
};
// -------------------------------------------------------------------

class TopPeerReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zproto.TopPeerReq) */ {
 public:
  TopPeerReq();
  virtual ~TopPeerReq();

  TopPeerReq(const TopPeerReq& from);

  inline TopPeerReq& operator=(const TopPeerReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TopPeerReq(TopPeerReq&& from) noexcept
    : TopPeerReq() {
    *this = ::std::move(from);
  }

  inline TopPeerReq& operator=(TopPeerReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TopPeerReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TopPeerReq* internal_default_instance() {
    return reinterpret_cast<const TopPeerReq*>(
               &_TopPeerReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(TopPeerReq* other);
  friend void swap(TopPeerReq& a, TopPeerReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TopPeerReq* New() const PROTOBUF_FINAL { return New(NULL); }

  TopPeerReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TopPeerReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .zproto.OutPeer peer = 1;
  bool has_peer() const;
  void clear_peer();
  static const int kPeerFieldNumber = 1;
  const ::zproto::OutPeer& peer() const;
  ::zproto::OutPeer* release_peer();
  ::zproto::OutPeer* mutable_peer();
  void set_allocated_peer(::zproto::OutPeer* peer);

  // @@protoc_insertion_point(class_scope:zproto.TopPeerReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::zproto::OutPeer* peer_;
  mutable int _cached_size_;
  friend struct ::protobuf_dialogs_2eproto::TableStruct;
  friend void ::protobuf_dialogs_2eproto::InitDefaultsTopPeerReqImpl();
};
// -------------------------------------------------------------------

class UntopPeerReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zproto.UntopPeerReq) */ {
 public:
  UntopPeerReq();
  virtual ~UntopPeerReq();

  UntopPeerReq(const UntopPeerReq& from);

  inline UntopPeerReq& operator=(const UntopPeerReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UntopPeerReq(UntopPeerReq&& from) noexcept
    : UntopPeerReq() {
    *this = ::std::move(from);
  }

  inline UntopPeerReq& operator=(UntopPeerReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UntopPeerReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UntopPeerReq* internal_default_instance() {
    return reinterpret_cast<const UntopPeerReq*>(
               &_UntopPeerReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(UntopPeerReq* other);
  friend void swap(UntopPeerReq& a, UntopPeerReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UntopPeerReq* New() const PROTOBUF_FINAL { return New(NULL); }

  UntopPeerReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UntopPeerReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .zproto.OutPeer peer = 1;
  bool has_peer() const;
  void clear_peer();
  static const int kPeerFieldNumber = 1;
  const ::zproto::OutPeer& peer() const;
  ::zproto::OutPeer* release_peer();
  ::zproto::OutPeer* mutable_peer();
  void set_allocated_peer(::zproto::OutPeer* peer);

  // @@protoc_insertion_point(class_scope:zproto.UntopPeerReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::zproto::OutPeer* peer_;
  mutable int _cached_size_;
  friend struct ::protobuf_dialogs_2eproto::TableStruct;
  friend void ::protobuf_dialogs_2eproto::InitDefaultsUntopPeerReqImpl();
};
// -------------------------------------------------------------------

class DndPeerReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zproto.DndPeerReq) */ {
 public:
  DndPeerReq();
  virtual ~DndPeerReq();

  DndPeerReq(const DndPeerReq& from);

  inline DndPeerReq& operator=(const DndPeerReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DndPeerReq(DndPeerReq&& from) noexcept
    : DndPeerReq() {
    *this = ::std::move(from);
  }

  inline DndPeerReq& operator=(DndPeerReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DndPeerReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DndPeerReq* internal_default_instance() {
    return reinterpret_cast<const DndPeerReq*>(
               &_DndPeerReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(DndPeerReq* other);
  friend void swap(DndPeerReq& a, DndPeerReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DndPeerReq* New() const PROTOBUF_FINAL { return New(NULL); }

  DndPeerReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DndPeerReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .zproto.OutPeer peer = 1;
  bool has_peer() const;
  void clear_peer();
  static const int kPeerFieldNumber = 1;
  const ::zproto::OutPeer& peer() const;
  ::zproto::OutPeer* release_peer();
  ::zproto::OutPeer* mutable_peer();
  void set_allocated_peer(::zproto::OutPeer* peer);

  // @@protoc_insertion_point(class_scope:zproto.DndPeerReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::zproto::OutPeer* peer_;
  mutable int _cached_size_;
  friend struct ::protobuf_dialogs_2eproto::TableStruct;
  friend void ::protobuf_dialogs_2eproto::InitDefaultsDndPeerReqImpl();
};
// -------------------------------------------------------------------

class UndndPeerReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zproto.UndndPeerReq) */ {
 public:
  UndndPeerReq();
  virtual ~UndndPeerReq();

  UndndPeerReq(const UndndPeerReq& from);

  inline UndndPeerReq& operator=(const UndndPeerReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UndndPeerReq(UndndPeerReq&& from) noexcept
    : UndndPeerReq() {
    *this = ::std::move(from);
  }

  inline UndndPeerReq& operator=(UndndPeerReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UndndPeerReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UndndPeerReq* internal_default_instance() {
    return reinterpret_cast<const UndndPeerReq*>(
               &_UndndPeerReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(UndndPeerReq* other);
  friend void swap(UndndPeerReq& a, UndndPeerReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UndndPeerReq* New() const PROTOBUF_FINAL { return New(NULL); }

  UndndPeerReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UndndPeerReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .zproto.OutPeer peer = 1;
  bool has_peer() const;
  void clear_peer();
  static const int kPeerFieldNumber = 1;
  const ::zproto::OutPeer& peer() const;
  ::zproto::OutPeer* release_peer();
  ::zproto::OutPeer* mutable_peer();
  void set_allocated_peer(::zproto::OutPeer* peer);

  // @@protoc_insertion_point(class_scope:zproto.UndndPeerReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::zproto::OutPeer* peer_;
  mutable int _cached_size_;
  friend struct ::protobuf_dialogs_2eproto::TableStruct;
  friend void ::protobuf_dialogs_2eproto::InitDefaultsUndndPeerReqImpl();
};
// -------------------------------------------------------------------

class LoadBlockedPeersReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zproto.LoadBlockedPeersReq) */ {
 public:
  LoadBlockedPeersReq();
  virtual ~LoadBlockedPeersReq();

  LoadBlockedPeersReq(const LoadBlockedPeersReq& from);

  inline LoadBlockedPeersReq& operator=(const LoadBlockedPeersReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoadBlockedPeersReq(LoadBlockedPeersReq&& from) noexcept
    : LoadBlockedPeersReq() {
    *this = ::std::move(from);
  }

  inline LoadBlockedPeersReq& operator=(LoadBlockedPeersReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoadBlockedPeersReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoadBlockedPeersReq* internal_default_instance() {
    return reinterpret_cast<const LoadBlockedPeersReq*>(
               &_LoadBlockedPeersReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(LoadBlockedPeersReq* other);
  friend void swap(LoadBlockedPeersReq& a, LoadBlockedPeersReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoadBlockedPeersReq* New() const PROTOBUF_FINAL { return New(NULL); }

  LoadBlockedPeersReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LoadBlockedPeersReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zproto.LoadBlockedPeersReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_dialogs_2eproto::TableStruct;
  friend void ::protobuf_dialogs_2eproto::InitDefaultsLoadBlockedPeersReqImpl();
};
// -------------------------------------------------------------------

class LoadBlockedPeersRsp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zproto.LoadBlockedPeersRsp) */ {
 public:
  LoadBlockedPeersRsp();
  virtual ~LoadBlockedPeersRsp();

  LoadBlockedPeersRsp(const LoadBlockedPeersRsp& from);

  inline LoadBlockedPeersRsp& operator=(const LoadBlockedPeersRsp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoadBlockedPeersRsp(LoadBlockedPeersRsp&& from) noexcept
    : LoadBlockedPeersRsp() {
    *this = ::std::move(from);
  }

  inline LoadBlockedPeersRsp& operator=(LoadBlockedPeersRsp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoadBlockedPeersRsp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoadBlockedPeersRsp* internal_default_instance() {
    return reinterpret_cast<const LoadBlockedPeersRsp*>(
               &_LoadBlockedPeersRsp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(LoadBlockedPeersRsp* other);
  friend void swap(LoadBlockedPeersRsp& a, LoadBlockedPeersRsp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoadBlockedPeersRsp* New() const PROTOBUF_FINAL { return New(NULL); }

  LoadBlockedPeersRsp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LoadBlockedPeersRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .zproto.OutPeer peers = 1;
  int peers_size() const;
  void clear_peers();
  static const int kPeersFieldNumber = 1;
  const ::zproto::OutPeer& peers(int index) const;
  ::zproto::OutPeer* mutable_peers(int index);
  ::zproto::OutPeer* add_peers();
  ::google::protobuf::RepeatedPtrField< ::zproto::OutPeer >*
      mutable_peers();
  const ::google::protobuf::RepeatedPtrField< ::zproto::OutPeer >&
      peers() const;

  // @@protoc_insertion_point(class_scope:zproto.LoadBlockedPeersRsp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::zproto::OutPeer > peers_;
  mutable int _cached_size_;
  friend struct ::protobuf_dialogs_2eproto::TableStruct;
  friend void ::protobuf_dialogs_2eproto::InitDefaultsLoadBlockedPeersRspImpl();
};
// -------------------------------------------------------------------

class LoadTopedPeersReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zproto.LoadTopedPeersReq) */ {
 public:
  LoadTopedPeersReq();
  virtual ~LoadTopedPeersReq();

  LoadTopedPeersReq(const LoadTopedPeersReq& from);

  inline LoadTopedPeersReq& operator=(const LoadTopedPeersReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoadTopedPeersReq(LoadTopedPeersReq&& from) noexcept
    : LoadTopedPeersReq() {
    *this = ::std::move(from);
  }

  inline LoadTopedPeersReq& operator=(LoadTopedPeersReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoadTopedPeersReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoadTopedPeersReq* internal_default_instance() {
    return reinterpret_cast<const LoadTopedPeersReq*>(
               &_LoadTopedPeersReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(LoadTopedPeersReq* other);
  friend void swap(LoadTopedPeersReq& a, LoadTopedPeersReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoadTopedPeersReq* New() const PROTOBUF_FINAL { return New(NULL); }

  LoadTopedPeersReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LoadTopedPeersReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zproto.LoadTopedPeersReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_dialogs_2eproto::TableStruct;
  friend void ::protobuf_dialogs_2eproto::InitDefaultsLoadTopedPeersReqImpl();
};
// -------------------------------------------------------------------

class LoadTopedPeersRsp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zproto.LoadTopedPeersRsp) */ {
 public:
  LoadTopedPeersRsp();
  virtual ~LoadTopedPeersRsp();

  LoadTopedPeersRsp(const LoadTopedPeersRsp& from);

  inline LoadTopedPeersRsp& operator=(const LoadTopedPeersRsp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoadTopedPeersRsp(LoadTopedPeersRsp&& from) noexcept
    : LoadTopedPeersRsp() {
    *this = ::std::move(from);
  }

  inline LoadTopedPeersRsp& operator=(LoadTopedPeersRsp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoadTopedPeersRsp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoadTopedPeersRsp* internal_default_instance() {
    return reinterpret_cast<const LoadTopedPeersRsp*>(
               &_LoadTopedPeersRsp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(LoadTopedPeersRsp* other);
  friend void swap(LoadTopedPeersRsp& a, LoadTopedPeersRsp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoadTopedPeersRsp* New() const PROTOBUF_FINAL { return New(NULL); }

  LoadTopedPeersRsp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LoadTopedPeersRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .zproto.OutPeer peers = 1;
  int peers_size() const;
  void clear_peers();
  static const int kPeersFieldNumber = 1;
  const ::zproto::OutPeer& peers(int index) const;
  ::zproto::OutPeer* mutable_peers(int index);
  ::zproto::OutPeer* add_peers();
  ::google::protobuf::RepeatedPtrField< ::zproto::OutPeer >*
      mutable_peers();
  const ::google::protobuf::RepeatedPtrField< ::zproto::OutPeer >&
      peers() const;

  // @@protoc_insertion_point(class_scope:zproto.LoadTopedPeersRsp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::zproto::OutPeer > peers_;
  mutable int _cached_size_;
  friend struct ::protobuf_dialogs_2eproto::TableStruct;
  friend void ::protobuf_dialogs_2eproto::InitDefaultsLoadTopedPeersRspImpl();
};
// -------------------------------------------------------------------

class LoadDndedPeersReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zproto.LoadDndedPeersReq) */ {
 public:
  LoadDndedPeersReq();
  virtual ~LoadDndedPeersReq();

  LoadDndedPeersReq(const LoadDndedPeersReq& from);

  inline LoadDndedPeersReq& operator=(const LoadDndedPeersReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoadDndedPeersReq(LoadDndedPeersReq&& from) noexcept
    : LoadDndedPeersReq() {
    *this = ::std::move(from);
  }

  inline LoadDndedPeersReq& operator=(LoadDndedPeersReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoadDndedPeersReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoadDndedPeersReq* internal_default_instance() {
    return reinterpret_cast<const LoadDndedPeersReq*>(
               &_LoadDndedPeersReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(LoadDndedPeersReq* other);
  friend void swap(LoadDndedPeersReq& a, LoadDndedPeersReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoadDndedPeersReq* New() const PROTOBUF_FINAL { return New(NULL); }

  LoadDndedPeersReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LoadDndedPeersReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zproto.LoadDndedPeersReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_dialogs_2eproto::TableStruct;
  friend void ::protobuf_dialogs_2eproto::InitDefaultsLoadDndedPeersReqImpl();
};
// -------------------------------------------------------------------

class LoadDndedPeersRsp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zproto.LoadDndedPeersRsp) */ {
 public:
  LoadDndedPeersRsp();
  virtual ~LoadDndedPeersRsp();

  LoadDndedPeersRsp(const LoadDndedPeersRsp& from);

  inline LoadDndedPeersRsp& operator=(const LoadDndedPeersRsp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoadDndedPeersRsp(LoadDndedPeersRsp&& from) noexcept
    : LoadDndedPeersRsp() {
    *this = ::std::move(from);
  }

  inline LoadDndedPeersRsp& operator=(LoadDndedPeersRsp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoadDndedPeersRsp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoadDndedPeersRsp* internal_default_instance() {
    return reinterpret_cast<const LoadDndedPeersRsp*>(
               &_LoadDndedPeersRsp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(LoadDndedPeersRsp* other);
  friend void swap(LoadDndedPeersRsp& a, LoadDndedPeersRsp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoadDndedPeersRsp* New() const PROTOBUF_FINAL { return New(NULL); }

  LoadDndedPeersRsp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LoadDndedPeersRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .zproto.OutPeer peers = 1;
  int peers_size() const;
  void clear_peers();
  static const int kPeersFieldNumber = 1;
  const ::zproto::OutPeer& peers(int index) const;
  ::zproto::OutPeer* mutable_peers(int index);
  ::zproto::OutPeer* add_peers();
  ::google::protobuf::RepeatedPtrField< ::zproto::OutPeer >*
      mutable_peers();
  const ::google::protobuf::RepeatedPtrField< ::zproto::OutPeer >&
      peers() const;

  // @@protoc_insertion_point(class_scope:zproto.LoadDndedPeersRsp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::zproto::OutPeer > peers_;
  mutable int _cached_size_;
  friend struct ::protobuf_dialogs_2eproto::TableStruct;
  friend void ::protobuf_dialogs_2eproto::InitDefaultsLoadDndedPeersRspImpl();
};
// -------------------------------------------------------------------

class PeerBlockedNotify : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zproto.PeerBlockedNotify) */ {
 public:
  PeerBlockedNotify();
  virtual ~PeerBlockedNotify();

  PeerBlockedNotify(const PeerBlockedNotify& from);

  inline PeerBlockedNotify& operator=(const PeerBlockedNotify& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PeerBlockedNotify(PeerBlockedNotify&& from) noexcept
    : PeerBlockedNotify() {
    *this = ::std::move(from);
  }

  inline PeerBlockedNotify& operator=(PeerBlockedNotify&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PeerBlockedNotify& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PeerBlockedNotify* internal_default_instance() {
    return reinterpret_cast<const PeerBlockedNotify*>(
               &_PeerBlockedNotify_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(PeerBlockedNotify* other);
  friend void swap(PeerBlockedNotify& a, PeerBlockedNotify& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PeerBlockedNotify* New() const PROTOBUF_FINAL { return New(NULL); }

  PeerBlockedNotify* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PeerBlockedNotify* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .zproto.Peer peer = 1;
  bool has_peer() const;
  void clear_peer();
  static const int kPeerFieldNumber = 1;
  const ::zproto::Peer& peer() const;
  ::zproto::Peer* release_peer();
  ::zproto::Peer* mutable_peer();
  void set_allocated_peer(::zproto::Peer* peer);

  // @@protoc_insertion_point(class_scope:zproto.PeerBlockedNotify)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::zproto::Peer* peer_;
  mutable int _cached_size_;
  friend struct ::protobuf_dialogs_2eproto::TableStruct;
  friend void ::protobuf_dialogs_2eproto::InitDefaultsPeerBlockedNotifyImpl();
};
// -------------------------------------------------------------------

class PeerUnblockedNotify : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zproto.PeerUnblockedNotify) */ {
 public:
  PeerUnblockedNotify();
  virtual ~PeerUnblockedNotify();

  PeerUnblockedNotify(const PeerUnblockedNotify& from);

  inline PeerUnblockedNotify& operator=(const PeerUnblockedNotify& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PeerUnblockedNotify(PeerUnblockedNotify&& from) noexcept
    : PeerUnblockedNotify() {
    *this = ::std::move(from);
  }

  inline PeerUnblockedNotify& operator=(PeerUnblockedNotify&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PeerUnblockedNotify& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PeerUnblockedNotify* internal_default_instance() {
    return reinterpret_cast<const PeerUnblockedNotify*>(
               &_PeerUnblockedNotify_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(PeerUnblockedNotify* other);
  friend void swap(PeerUnblockedNotify& a, PeerUnblockedNotify& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PeerUnblockedNotify* New() const PROTOBUF_FINAL { return New(NULL); }

  PeerUnblockedNotify* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PeerUnblockedNotify* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .zproto.Peer peer = 1;
  bool has_peer() const;
  void clear_peer();
  static const int kPeerFieldNumber = 1;
  const ::zproto::Peer& peer() const;
  ::zproto::Peer* release_peer();
  ::zproto::Peer* mutable_peer();
  void set_allocated_peer(::zproto::Peer* peer);

  // @@protoc_insertion_point(class_scope:zproto.PeerUnblockedNotify)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::zproto::Peer* peer_;
  mutable int _cached_size_;
  friend struct ::protobuf_dialogs_2eproto::TableStruct;
  friend void ::protobuf_dialogs_2eproto::InitDefaultsPeerUnblockedNotifyImpl();
};
// -------------------------------------------------------------------

class PeerTopedNotify : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zproto.PeerTopedNotify) */ {
 public:
  PeerTopedNotify();
  virtual ~PeerTopedNotify();

  PeerTopedNotify(const PeerTopedNotify& from);

  inline PeerTopedNotify& operator=(const PeerTopedNotify& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PeerTopedNotify(PeerTopedNotify&& from) noexcept
    : PeerTopedNotify() {
    *this = ::std::move(from);
  }

  inline PeerTopedNotify& operator=(PeerTopedNotify&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PeerTopedNotify& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PeerTopedNotify* internal_default_instance() {
    return reinterpret_cast<const PeerTopedNotify*>(
               &_PeerTopedNotify_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(PeerTopedNotify* other);
  friend void swap(PeerTopedNotify& a, PeerTopedNotify& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PeerTopedNotify* New() const PROTOBUF_FINAL { return New(NULL); }

  PeerTopedNotify* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PeerTopedNotify* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .zproto.Peer peer = 1;
  bool has_peer() const;
  void clear_peer();
  static const int kPeerFieldNumber = 1;
  const ::zproto::Peer& peer() const;
  ::zproto::Peer* release_peer();
  ::zproto::Peer* mutable_peer();
  void set_allocated_peer(::zproto::Peer* peer);

  // @@protoc_insertion_point(class_scope:zproto.PeerTopedNotify)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::zproto::Peer* peer_;
  mutable int _cached_size_;
  friend struct ::protobuf_dialogs_2eproto::TableStruct;
  friend void ::protobuf_dialogs_2eproto::InitDefaultsPeerTopedNotifyImpl();
};
// -------------------------------------------------------------------

class PeerUntopedNotify : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zproto.PeerUntopedNotify) */ {
 public:
  PeerUntopedNotify();
  virtual ~PeerUntopedNotify();

  PeerUntopedNotify(const PeerUntopedNotify& from);

  inline PeerUntopedNotify& operator=(const PeerUntopedNotify& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PeerUntopedNotify(PeerUntopedNotify&& from) noexcept
    : PeerUntopedNotify() {
    *this = ::std::move(from);
  }

  inline PeerUntopedNotify& operator=(PeerUntopedNotify&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PeerUntopedNotify& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PeerUntopedNotify* internal_default_instance() {
    return reinterpret_cast<const PeerUntopedNotify*>(
               &_PeerUntopedNotify_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(PeerUntopedNotify* other);
  friend void swap(PeerUntopedNotify& a, PeerUntopedNotify& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PeerUntopedNotify* New() const PROTOBUF_FINAL { return New(NULL); }

  PeerUntopedNotify* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PeerUntopedNotify* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .zproto.Peer peer = 1;
  bool has_peer() const;
  void clear_peer();
  static const int kPeerFieldNumber = 1;
  const ::zproto::Peer& peer() const;
  ::zproto::Peer* release_peer();
  ::zproto::Peer* mutable_peer();
  void set_allocated_peer(::zproto::Peer* peer);

  // @@protoc_insertion_point(class_scope:zproto.PeerUntopedNotify)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::zproto::Peer* peer_;
  mutable int _cached_size_;
  friend struct ::protobuf_dialogs_2eproto::TableStruct;
  friend void ::protobuf_dialogs_2eproto::InitDefaultsPeerUntopedNotifyImpl();
};
// -------------------------------------------------------------------

class PeerDndedNotify : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zproto.PeerDndedNotify) */ {
 public:
  PeerDndedNotify();
  virtual ~PeerDndedNotify();

  PeerDndedNotify(const PeerDndedNotify& from);

  inline PeerDndedNotify& operator=(const PeerDndedNotify& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PeerDndedNotify(PeerDndedNotify&& from) noexcept
    : PeerDndedNotify() {
    *this = ::std::move(from);
  }

  inline PeerDndedNotify& operator=(PeerDndedNotify&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PeerDndedNotify& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PeerDndedNotify* internal_default_instance() {
    return reinterpret_cast<const PeerDndedNotify*>(
               &_PeerDndedNotify_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(PeerDndedNotify* other);
  friend void swap(PeerDndedNotify& a, PeerDndedNotify& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PeerDndedNotify* New() const PROTOBUF_FINAL { return New(NULL); }

  PeerDndedNotify* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PeerDndedNotify* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .zproto.Peer peer = 1;
  bool has_peer() const;
  void clear_peer();
  static const int kPeerFieldNumber = 1;
  const ::zproto::Peer& peer() const;
  ::zproto::Peer* release_peer();
  ::zproto::Peer* mutable_peer();
  void set_allocated_peer(::zproto::Peer* peer);

  // @@protoc_insertion_point(class_scope:zproto.PeerDndedNotify)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::zproto::Peer* peer_;
  mutable int _cached_size_;
  friend struct ::protobuf_dialogs_2eproto::TableStruct;
  friend void ::protobuf_dialogs_2eproto::InitDefaultsPeerDndedNotifyImpl();
};
// -------------------------------------------------------------------

class PeerUndndedNotify : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zproto.PeerUndndedNotify) */ {
 public:
  PeerUndndedNotify();
  virtual ~PeerUndndedNotify();

  PeerUndndedNotify(const PeerUndndedNotify& from);

  inline PeerUndndedNotify& operator=(const PeerUndndedNotify& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PeerUndndedNotify(PeerUndndedNotify&& from) noexcept
    : PeerUndndedNotify() {
    *this = ::std::move(from);
  }

  inline PeerUndndedNotify& operator=(PeerUndndedNotify&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PeerUndndedNotify& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PeerUndndedNotify* internal_default_instance() {
    return reinterpret_cast<const PeerUndndedNotify*>(
               &_PeerUndndedNotify_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(PeerUndndedNotify* other);
  friend void swap(PeerUndndedNotify& a, PeerUndndedNotify& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PeerUndndedNotify* New() const PROTOBUF_FINAL { return New(NULL); }

  PeerUndndedNotify* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PeerUndndedNotify* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .zproto.Peer peer = 1;
  bool has_peer() const;
  void clear_peer();
  static const int kPeerFieldNumber = 1;
  const ::zproto::Peer& peer() const;
  ::zproto::Peer* release_peer();
  ::zproto::Peer* mutable_peer();
  void set_allocated_peer(::zproto::Peer* peer);

  // @@protoc_insertion_point(class_scope:zproto.PeerUndndedNotify)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::zproto::Peer* peer_;
  mutable int _cached_size_;
  friend struct ::protobuf_dialogs_2eproto::TableStruct;
  friend void ::protobuf_dialogs_2eproto::InitDefaultsPeerUndndedNotifyImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Dialog

// .zproto.Peer peer = 1;
inline bool Dialog::has_peer() const {
  return this != internal_default_instance() && peer_ != NULL;
}
inline const ::zproto::Peer& Dialog::peer() const {
  const ::zproto::Peer* p = peer_;
  // @@protoc_insertion_point(field_get:zproto.Dialog.peer)
  return p != NULL ? *p : *reinterpret_cast<const ::zproto::Peer*>(
      &::zproto::_Peer_default_instance_);
}
inline ::zproto::Peer* Dialog::release_peer() {
  // @@protoc_insertion_point(field_release:zproto.Dialog.peer)
  
  ::zproto::Peer* temp = peer_;
  peer_ = NULL;
  return temp;
}
inline ::zproto::Peer* Dialog::mutable_peer() {
  
  if (peer_ == NULL) {
    peer_ = new ::zproto::Peer;
  }
  // @@protoc_insertion_point(field_mutable:zproto.Dialog.peer)
  return peer_;
}
inline void Dialog::set_allocated_peer(::zproto::Peer* peer) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(peer_);
  }
  if (peer) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      peer = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, peer, submessage_arena);
    }
    
  } else {
    
  }
  peer_ = peer;
  // @@protoc_insertion_point(field_set_allocated:zproto.Dialog.peer)
}

// int32 unread_count = 2;
inline void Dialog::clear_unread_count() {
  unread_count_ = 0;
}
inline ::google::protobuf::int32 Dialog::unread_count() const {
  // @@protoc_insertion_point(field_get:zproto.Dialog.unread_count)
  return unread_count_;
}
inline void Dialog::set_unread_count(::google::protobuf::int32 value) {
  
  unread_count_ = value;
  // @@protoc_insertion_point(field_set:zproto.Dialog.unread_count)
}

// int64 sort_date = 3;
inline void Dialog::clear_sort_date() {
  sort_date_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Dialog::sort_date() const {
  // @@protoc_insertion_point(field_get:zproto.Dialog.sort_date)
  return sort_date_;
}
inline void Dialog::set_sort_date(::google::protobuf::int64 value) {
  
  sort_date_ = value;
  // @@protoc_insertion_point(field_set:zproto.Dialog.sort_date)
}

// .zproto.MessageContainer last_message = 4;
inline bool Dialog::has_last_message() const {
  return this != internal_default_instance() && last_message_ != NULL;
}
inline const ::zproto::MessageContainer& Dialog::last_message() const {
  const ::zproto::MessageContainer* p = last_message_;
  // @@protoc_insertion_point(field_get:zproto.Dialog.last_message)
  return p != NULL ? *p : *reinterpret_cast<const ::zproto::MessageContainer*>(
      &::zproto::_MessageContainer_default_instance_);
}
inline ::zproto::MessageContainer* Dialog::release_last_message() {
  // @@protoc_insertion_point(field_release:zproto.Dialog.last_message)
  
  ::zproto::MessageContainer* temp = last_message_;
  last_message_ = NULL;
  return temp;
}
inline ::zproto::MessageContainer* Dialog::mutable_last_message() {
  
  if (last_message_ == NULL) {
    last_message_ = new ::zproto::MessageContainer;
  }
  // @@protoc_insertion_point(field_mutable:zproto.Dialog.last_message)
  return last_message_;
}
inline void Dialog::set_allocated_last_message(::zproto::MessageContainer* last_message) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(last_message_);
  }
  if (last_message) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      last_message = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, last_message, submessage_arena);
    }
    
  } else {
    
  }
  last_message_ = last_message;
  // @@protoc_insertion_point(field_set_allocated:zproto.Dialog.last_message)
}

// int64 first_unread_date = 5;
inline void Dialog::clear_first_unread_date() {
  first_unread_date_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Dialog::first_unread_date() const {
  // @@protoc_insertion_point(field_get:zproto.Dialog.first_unread_date)
  return first_unread_date_;
}
inline void Dialog::set_first_unread_date(::google::protobuf::int64 value) {
  
  first_unread_date_ = value;
  // @@protoc_insertion_point(field_set:zproto.Dialog.first_unread_date)
}

// -------------------------------------------------------------------

// LoadDialogsReq

// int64 min_date = 1;
inline void LoadDialogsReq::clear_min_date() {
  min_date_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LoadDialogsReq::min_date() const {
  // @@protoc_insertion_point(field_get:zproto.LoadDialogsReq.min_date)
  return min_date_;
}
inline void LoadDialogsReq::set_min_date(::google::protobuf::int64 value) {
  
  min_date_ = value;
  // @@protoc_insertion_point(field_set:zproto.LoadDialogsReq.min_date)
}

// .zproto.ListLoadMode load_mode = 2;
inline void LoadDialogsReq::clear_load_mode() {
  load_mode_ = 0;
}
inline ::zproto::ListLoadMode LoadDialogsReq::load_mode() const {
  // @@protoc_insertion_point(field_get:zproto.LoadDialogsReq.load_mode)
  return static_cast< ::zproto::ListLoadMode >(load_mode_);
}
inline void LoadDialogsReq::set_load_mode(::zproto::ListLoadMode value) {
  
  load_mode_ = value;
  // @@protoc_insertion_point(field_set:zproto.LoadDialogsReq.load_mode)
}

// int32 limit = 3;
inline void LoadDialogsReq::clear_limit() {
  limit_ = 0;
}
inline ::google::protobuf::int32 LoadDialogsReq::limit() const {
  // @@protoc_insertion_point(field_get:zproto.LoadDialogsReq.limit)
  return limit_;
}
inline void LoadDialogsReq::set_limit(::google::protobuf::int32 value) {
  
  limit_ = value;
  // @@protoc_insertion_point(field_set:zproto.LoadDialogsReq.limit)
}

// -------------------------------------------------------------------

// LoadDialogsRsp

// repeated .zproto.Group groups = 1;
inline int LoadDialogsRsp::groups_size() const {
  return groups_.size();
}
inline const ::zproto::Group& LoadDialogsRsp::groups(int index) const {
  // @@protoc_insertion_point(field_get:zproto.LoadDialogsRsp.groups)
  return groups_.Get(index);
}
inline ::zproto::Group* LoadDialogsRsp::mutable_groups(int index) {
  // @@protoc_insertion_point(field_mutable:zproto.LoadDialogsRsp.groups)
  return groups_.Mutable(index);
}
inline ::zproto::Group* LoadDialogsRsp::add_groups() {
  // @@protoc_insertion_point(field_add:zproto.LoadDialogsRsp.groups)
  return groups_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::zproto::Group >*
LoadDialogsRsp::mutable_groups() {
  // @@protoc_insertion_point(field_mutable_list:zproto.LoadDialogsRsp.groups)
  return &groups_;
}
inline const ::google::protobuf::RepeatedPtrField< ::zproto::Group >&
LoadDialogsRsp::groups() const {
  // @@protoc_insertion_point(field_list:zproto.LoadDialogsRsp.groups)
  return groups_;
}

// repeated .zproto.User users = 2;
inline int LoadDialogsRsp::users_size() const {
  return users_.size();
}
inline const ::zproto::User& LoadDialogsRsp::users(int index) const {
  // @@protoc_insertion_point(field_get:zproto.LoadDialogsRsp.users)
  return users_.Get(index);
}
inline ::zproto::User* LoadDialogsRsp::mutable_users(int index) {
  // @@protoc_insertion_point(field_mutable:zproto.LoadDialogsRsp.users)
  return users_.Mutable(index);
}
inline ::zproto::User* LoadDialogsRsp::add_users() {
  // @@protoc_insertion_point(field_add:zproto.LoadDialogsRsp.users)
  return users_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::zproto::User >*
LoadDialogsRsp::mutable_users() {
  // @@protoc_insertion_point(field_mutable_list:zproto.LoadDialogsRsp.users)
  return &users_;
}
inline const ::google::protobuf::RepeatedPtrField< ::zproto::User >&
LoadDialogsRsp::users() const {
  // @@protoc_insertion_point(field_list:zproto.LoadDialogsRsp.users)
  return users_;
}

// repeated .zproto.Dialog dialogs = 3;
inline int LoadDialogsRsp::dialogs_size() const {
  return dialogs_.size();
}
inline void LoadDialogsRsp::clear_dialogs() {
  dialogs_.Clear();
}
inline const ::zproto::Dialog& LoadDialogsRsp::dialogs(int index) const {
  // @@protoc_insertion_point(field_get:zproto.LoadDialogsRsp.dialogs)
  return dialogs_.Get(index);
}
inline ::zproto::Dialog* LoadDialogsRsp::mutable_dialogs(int index) {
  // @@protoc_insertion_point(field_mutable:zproto.LoadDialogsRsp.dialogs)
  return dialogs_.Mutable(index);
}
inline ::zproto::Dialog* LoadDialogsRsp::add_dialogs() {
  // @@protoc_insertion_point(field_add:zproto.LoadDialogsRsp.dialogs)
  return dialogs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::zproto::Dialog >*
LoadDialogsRsp::mutable_dialogs() {
  // @@protoc_insertion_point(field_mutable_list:zproto.LoadDialogsRsp.dialogs)
  return &dialogs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::zproto::Dialog >&
LoadDialogsRsp::dialogs() const {
  // @@protoc_insertion_point(field_list:zproto.LoadDialogsRsp.dialogs)
  return dialogs_;
}

// repeated .zproto.UserOutPeer user_peers = 4;
inline int LoadDialogsRsp::user_peers_size() const {
  return user_peers_.size();
}
inline const ::zproto::UserOutPeer& LoadDialogsRsp::user_peers(int index) const {
  // @@protoc_insertion_point(field_get:zproto.LoadDialogsRsp.user_peers)
  return user_peers_.Get(index);
}
inline ::zproto::UserOutPeer* LoadDialogsRsp::mutable_user_peers(int index) {
  // @@protoc_insertion_point(field_mutable:zproto.LoadDialogsRsp.user_peers)
  return user_peers_.Mutable(index);
}
inline ::zproto::UserOutPeer* LoadDialogsRsp::add_user_peers() {
  // @@protoc_insertion_point(field_add:zproto.LoadDialogsRsp.user_peers)
  return user_peers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::zproto::UserOutPeer >*
LoadDialogsRsp::mutable_user_peers() {
  // @@protoc_insertion_point(field_mutable_list:zproto.LoadDialogsRsp.user_peers)
  return &user_peers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::zproto::UserOutPeer >&
LoadDialogsRsp::user_peers() const {
  // @@protoc_insertion_point(field_list:zproto.LoadDialogsRsp.user_peers)
  return user_peers_;
}

// repeated .zproto.GroupOutPeer group_peers = 5;
inline int LoadDialogsRsp::group_peers_size() const {
  return group_peers_.size();
}
inline const ::zproto::GroupOutPeer& LoadDialogsRsp::group_peers(int index) const {
  // @@protoc_insertion_point(field_get:zproto.LoadDialogsRsp.group_peers)
  return group_peers_.Get(index);
}
inline ::zproto::GroupOutPeer* LoadDialogsRsp::mutable_group_peers(int index) {
  // @@protoc_insertion_point(field_mutable:zproto.LoadDialogsRsp.group_peers)
  return group_peers_.Mutable(index);
}
inline ::zproto::GroupOutPeer* LoadDialogsRsp::add_group_peers() {
  // @@protoc_insertion_point(field_add:zproto.LoadDialogsRsp.group_peers)
  return group_peers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::zproto::GroupOutPeer >*
LoadDialogsRsp::mutable_group_peers() {
  // @@protoc_insertion_point(field_mutable_list:zproto.LoadDialogsRsp.group_peers)
  return &group_peers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::zproto::GroupOutPeer >&
LoadDialogsRsp::group_peers() const {
  // @@protoc_insertion_point(field_list:zproto.LoadDialogsRsp.group_peers)
  return group_peers_;
}

// -------------------------------------------------------------------

// CreateChatDialogReq

// string peer_id = 1;
inline void CreateChatDialogReq::clear_peer_id() {
  peer_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreateChatDialogReq::peer_id() const {
  // @@protoc_insertion_point(field_get:zproto.CreateChatDialogReq.peer_id)
  return peer_id_.GetNoArena();
}
inline void CreateChatDialogReq::set_peer_id(const ::std::string& value) {
  
  peer_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zproto.CreateChatDialogReq.peer_id)
}
#if LANG_CXX11
inline void CreateChatDialogReq::set_peer_id(::std::string&& value) {
  
  peer_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zproto.CreateChatDialogReq.peer_id)
}
#endif
inline void CreateChatDialogReq::set_peer_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  peer_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zproto.CreateChatDialogReq.peer_id)
}
inline void CreateChatDialogReq::set_peer_id(const char* value, size_t size) {
  
  peer_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zproto.CreateChatDialogReq.peer_id)
}
inline ::std::string* CreateChatDialogReq::mutable_peer_id() {
  
  // @@protoc_insertion_point(field_mutable:zproto.CreateChatDialogReq.peer_id)
  return peer_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateChatDialogReq::release_peer_id() {
  // @@protoc_insertion_point(field_release:zproto.CreateChatDialogReq.peer_id)
  
  return peer_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateChatDialogReq::set_allocated_peer_id(::std::string* peer_id) {
  if (peer_id != NULL) {
    
  } else {
    
  }
  peer_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), peer_id);
  // @@protoc_insertion_point(field_set_allocated:zproto.CreateChatDialogReq.peer_id)
}

// -------------------------------------------------------------------

// CreateChatDialogRsp

// .zproto.OutPeer peer = 1;
inline bool CreateChatDialogRsp::has_peer() const {
  return this != internal_default_instance() && peer_ != NULL;
}
inline const ::zproto::OutPeer& CreateChatDialogRsp::peer() const {
  const ::zproto::OutPeer* p = peer_;
  // @@protoc_insertion_point(field_get:zproto.CreateChatDialogRsp.peer)
  return p != NULL ? *p : *reinterpret_cast<const ::zproto::OutPeer*>(
      &::zproto::_OutPeer_default_instance_);
}
inline ::zproto::OutPeer* CreateChatDialogRsp::release_peer() {
  // @@protoc_insertion_point(field_release:zproto.CreateChatDialogRsp.peer)
  
  ::zproto::OutPeer* temp = peer_;
  peer_ = NULL;
  return temp;
}
inline ::zproto::OutPeer* CreateChatDialogRsp::mutable_peer() {
  
  if (peer_ == NULL) {
    peer_ = new ::zproto::OutPeer;
  }
  // @@protoc_insertion_point(field_mutable:zproto.CreateChatDialogRsp.peer)
  return peer_;
}
inline void CreateChatDialogRsp::set_allocated_peer(::zproto::OutPeer* peer) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(peer_);
  }
  if (peer) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      peer = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, peer, submessage_arena);
    }
    
  } else {
    
  }
  peer_ = peer;
  // @@protoc_insertion_point(field_set_allocated:zproto.CreateChatDialogRsp.peer)
}

// -------------------------------------------------------------------

// BlockPeerReq

// .zproto.OutPeer peer = 1;
inline bool BlockPeerReq::has_peer() const {
  return this != internal_default_instance() && peer_ != NULL;
}
inline const ::zproto::OutPeer& BlockPeerReq::peer() const {
  const ::zproto::OutPeer* p = peer_;
  // @@protoc_insertion_point(field_get:zproto.BlockPeerReq.peer)
  return p != NULL ? *p : *reinterpret_cast<const ::zproto::OutPeer*>(
      &::zproto::_OutPeer_default_instance_);
}
inline ::zproto::OutPeer* BlockPeerReq::release_peer() {
  // @@protoc_insertion_point(field_release:zproto.BlockPeerReq.peer)
  
  ::zproto::OutPeer* temp = peer_;
  peer_ = NULL;
  return temp;
}
inline ::zproto::OutPeer* BlockPeerReq::mutable_peer() {
  
  if (peer_ == NULL) {
    peer_ = new ::zproto::OutPeer;
  }
  // @@protoc_insertion_point(field_mutable:zproto.BlockPeerReq.peer)
  return peer_;
}
inline void BlockPeerReq::set_allocated_peer(::zproto::OutPeer* peer) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(peer_);
  }
  if (peer) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      peer = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, peer, submessage_arena);
    }
    
  } else {
    
  }
  peer_ = peer;
  // @@protoc_insertion_point(field_set_allocated:zproto.BlockPeerReq.peer)
}

// -------------------------------------------------------------------

// UnblockPeerReq

// .zproto.OutPeer peer = 1;
inline bool UnblockPeerReq::has_peer() const {
  return this != internal_default_instance() && peer_ != NULL;
}
inline const ::zproto::OutPeer& UnblockPeerReq::peer() const {
  const ::zproto::OutPeer* p = peer_;
  // @@protoc_insertion_point(field_get:zproto.UnblockPeerReq.peer)
  return p != NULL ? *p : *reinterpret_cast<const ::zproto::OutPeer*>(
      &::zproto::_OutPeer_default_instance_);
}
inline ::zproto::OutPeer* UnblockPeerReq::release_peer() {
  // @@protoc_insertion_point(field_release:zproto.UnblockPeerReq.peer)
  
  ::zproto::OutPeer* temp = peer_;
  peer_ = NULL;
  return temp;
}
inline ::zproto::OutPeer* UnblockPeerReq::mutable_peer() {
  
  if (peer_ == NULL) {
    peer_ = new ::zproto::OutPeer;
  }
  // @@protoc_insertion_point(field_mutable:zproto.UnblockPeerReq.peer)
  return peer_;
}
inline void UnblockPeerReq::set_allocated_peer(::zproto::OutPeer* peer) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(peer_);
  }
  if (peer) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      peer = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, peer, submessage_arena);
    }
    
  } else {
    
  }
  peer_ = peer;
  // @@protoc_insertion_point(field_set_allocated:zproto.UnblockPeerReq.peer)
}

// -------------------------------------------------------------------

// TopPeerReq

// .zproto.OutPeer peer = 1;
inline bool TopPeerReq::has_peer() const {
  return this != internal_default_instance() && peer_ != NULL;
}
inline const ::zproto::OutPeer& TopPeerReq::peer() const {
  const ::zproto::OutPeer* p = peer_;
  // @@protoc_insertion_point(field_get:zproto.TopPeerReq.peer)
  return p != NULL ? *p : *reinterpret_cast<const ::zproto::OutPeer*>(
      &::zproto::_OutPeer_default_instance_);
}
inline ::zproto::OutPeer* TopPeerReq::release_peer() {
  // @@protoc_insertion_point(field_release:zproto.TopPeerReq.peer)
  
  ::zproto::OutPeer* temp = peer_;
  peer_ = NULL;
  return temp;
}
inline ::zproto::OutPeer* TopPeerReq::mutable_peer() {
  
  if (peer_ == NULL) {
    peer_ = new ::zproto::OutPeer;
  }
  // @@protoc_insertion_point(field_mutable:zproto.TopPeerReq.peer)
  return peer_;
}
inline void TopPeerReq::set_allocated_peer(::zproto::OutPeer* peer) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(peer_);
  }
  if (peer) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      peer = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, peer, submessage_arena);
    }
    
  } else {
    
  }
  peer_ = peer;
  // @@protoc_insertion_point(field_set_allocated:zproto.TopPeerReq.peer)
}

// -------------------------------------------------------------------

// UntopPeerReq

// .zproto.OutPeer peer = 1;
inline bool UntopPeerReq::has_peer() const {
  return this != internal_default_instance() && peer_ != NULL;
}
inline const ::zproto::OutPeer& UntopPeerReq::peer() const {
  const ::zproto::OutPeer* p = peer_;
  // @@protoc_insertion_point(field_get:zproto.UntopPeerReq.peer)
  return p != NULL ? *p : *reinterpret_cast<const ::zproto::OutPeer*>(
      &::zproto::_OutPeer_default_instance_);
}
inline ::zproto::OutPeer* UntopPeerReq::release_peer() {
  // @@protoc_insertion_point(field_release:zproto.UntopPeerReq.peer)
  
  ::zproto::OutPeer* temp = peer_;
  peer_ = NULL;
  return temp;
}
inline ::zproto::OutPeer* UntopPeerReq::mutable_peer() {
  
  if (peer_ == NULL) {
    peer_ = new ::zproto::OutPeer;
  }
  // @@protoc_insertion_point(field_mutable:zproto.UntopPeerReq.peer)
  return peer_;
}
inline void UntopPeerReq::set_allocated_peer(::zproto::OutPeer* peer) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(peer_);
  }
  if (peer) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      peer = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, peer, submessage_arena);
    }
    
  } else {
    
  }
  peer_ = peer;
  // @@protoc_insertion_point(field_set_allocated:zproto.UntopPeerReq.peer)
}

// -------------------------------------------------------------------

// DndPeerReq

// .zproto.OutPeer peer = 1;
inline bool DndPeerReq::has_peer() const {
  return this != internal_default_instance() && peer_ != NULL;
}
inline const ::zproto::OutPeer& DndPeerReq::peer() const {
  const ::zproto::OutPeer* p = peer_;
  // @@protoc_insertion_point(field_get:zproto.DndPeerReq.peer)
  return p != NULL ? *p : *reinterpret_cast<const ::zproto::OutPeer*>(
      &::zproto::_OutPeer_default_instance_);
}
inline ::zproto::OutPeer* DndPeerReq::release_peer() {
  // @@protoc_insertion_point(field_release:zproto.DndPeerReq.peer)
  
  ::zproto::OutPeer* temp = peer_;
  peer_ = NULL;
  return temp;
}
inline ::zproto::OutPeer* DndPeerReq::mutable_peer() {
  
  if (peer_ == NULL) {
    peer_ = new ::zproto::OutPeer;
  }
  // @@protoc_insertion_point(field_mutable:zproto.DndPeerReq.peer)
  return peer_;
}
inline void DndPeerReq::set_allocated_peer(::zproto::OutPeer* peer) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(peer_);
  }
  if (peer) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      peer = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, peer, submessage_arena);
    }
    
  } else {
    
  }
  peer_ = peer;
  // @@protoc_insertion_point(field_set_allocated:zproto.DndPeerReq.peer)
}

// -------------------------------------------------------------------

// UndndPeerReq

// .zproto.OutPeer peer = 1;
inline bool UndndPeerReq::has_peer() const {
  return this != internal_default_instance() && peer_ != NULL;
}
inline const ::zproto::OutPeer& UndndPeerReq::peer() const {
  const ::zproto::OutPeer* p = peer_;
  // @@protoc_insertion_point(field_get:zproto.UndndPeerReq.peer)
  return p != NULL ? *p : *reinterpret_cast<const ::zproto::OutPeer*>(
      &::zproto::_OutPeer_default_instance_);
}
inline ::zproto::OutPeer* UndndPeerReq::release_peer() {
  // @@protoc_insertion_point(field_release:zproto.UndndPeerReq.peer)
  
  ::zproto::OutPeer* temp = peer_;
  peer_ = NULL;
  return temp;
}
inline ::zproto::OutPeer* UndndPeerReq::mutable_peer() {
  
  if (peer_ == NULL) {
    peer_ = new ::zproto::OutPeer;
  }
  // @@protoc_insertion_point(field_mutable:zproto.UndndPeerReq.peer)
  return peer_;
}
inline void UndndPeerReq::set_allocated_peer(::zproto::OutPeer* peer) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(peer_);
  }
  if (peer) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      peer = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, peer, submessage_arena);
    }
    
  } else {
    
  }
  peer_ = peer;
  // @@protoc_insertion_point(field_set_allocated:zproto.UndndPeerReq.peer)
}

// -------------------------------------------------------------------

// LoadBlockedPeersReq

// -------------------------------------------------------------------

// LoadBlockedPeersRsp

// repeated .zproto.OutPeer peers = 1;
inline int LoadBlockedPeersRsp::peers_size() const {
  return peers_.size();
}
inline const ::zproto::OutPeer& LoadBlockedPeersRsp::peers(int index) const {
  // @@protoc_insertion_point(field_get:zproto.LoadBlockedPeersRsp.peers)
  return peers_.Get(index);
}
inline ::zproto::OutPeer* LoadBlockedPeersRsp::mutable_peers(int index) {
  // @@protoc_insertion_point(field_mutable:zproto.LoadBlockedPeersRsp.peers)
  return peers_.Mutable(index);
}
inline ::zproto::OutPeer* LoadBlockedPeersRsp::add_peers() {
  // @@protoc_insertion_point(field_add:zproto.LoadBlockedPeersRsp.peers)
  return peers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::zproto::OutPeer >*
LoadBlockedPeersRsp::mutable_peers() {
  // @@protoc_insertion_point(field_mutable_list:zproto.LoadBlockedPeersRsp.peers)
  return &peers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::zproto::OutPeer >&
LoadBlockedPeersRsp::peers() const {
  // @@protoc_insertion_point(field_list:zproto.LoadBlockedPeersRsp.peers)
  return peers_;
}

// -------------------------------------------------------------------

// LoadTopedPeersReq

// -------------------------------------------------------------------

// LoadTopedPeersRsp

// repeated .zproto.OutPeer peers = 1;
inline int LoadTopedPeersRsp::peers_size() const {
  return peers_.size();
}
inline const ::zproto::OutPeer& LoadTopedPeersRsp::peers(int index) const {
  // @@protoc_insertion_point(field_get:zproto.LoadTopedPeersRsp.peers)
  return peers_.Get(index);
}
inline ::zproto::OutPeer* LoadTopedPeersRsp::mutable_peers(int index) {
  // @@protoc_insertion_point(field_mutable:zproto.LoadTopedPeersRsp.peers)
  return peers_.Mutable(index);
}
inline ::zproto::OutPeer* LoadTopedPeersRsp::add_peers() {
  // @@protoc_insertion_point(field_add:zproto.LoadTopedPeersRsp.peers)
  return peers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::zproto::OutPeer >*
LoadTopedPeersRsp::mutable_peers() {
  // @@protoc_insertion_point(field_mutable_list:zproto.LoadTopedPeersRsp.peers)
  return &peers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::zproto::OutPeer >&
LoadTopedPeersRsp::peers() const {
  // @@protoc_insertion_point(field_list:zproto.LoadTopedPeersRsp.peers)
  return peers_;
}

// -------------------------------------------------------------------

// LoadDndedPeersReq

// -------------------------------------------------------------------

// LoadDndedPeersRsp

// repeated .zproto.OutPeer peers = 1;
inline int LoadDndedPeersRsp::peers_size() const {
  return peers_.size();
}
inline const ::zproto::OutPeer& LoadDndedPeersRsp::peers(int index) const {
  // @@protoc_insertion_point(field_get:zproto.LoadDndedPeersRsp.peers)
  return peers_.Get(index);
}
inline ::zproto::OutPeer* LoadDndedPeersRsp::mutable_peers(int index) {
  // @@protoc_insertion_point(field_mutable:zproto.LoadDndedPeersRsp.peers)
  return peers_.Mutable(index);
}
inline ::zproto::OutPeer* LoadDndedPeersRsp::add_peers() {
  // @@protoc_insertion_point(field_add:zproto.LoadDndedPeersRsp.peers)
  return peers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::zproto::OutPeer >*
LoadDndedPeersRsp::mutable_peers() {
  // @@protoc_insertion_point(field_mutable_list:zproto.LoadDndedPeersRsp.peers)
  return &peers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::zproto::OutPeer >&
LoadDndedPeersRsp::peers() const {
  // @@protoc_insertion_point(field_list:zproto.LoadDndedPeersRsp.peers)
  return peers_;
}

// -------------------------------------------------------------------

// PeerBlockedNotify

// .zproto.Peer peer = 1;
inline bool PeerBlockedNotify::has_peer() const {
  return this != internal_default_instance() && peer_ != NULL;
}
inline const ::zproto::Peer& PeerBlockedNotify::peer() const {
  const ::zproto::Peer* p = peer_;
  // @@protoc_insertion_point(field_get:zproto.PeerBlockedNotify.peer)
  return p != NULL ? *p : *reinterpret_cast<const ::zproto::Peer*>(
      &::zproto::_Peer_default_instance_);
}
inline ::zproto::Peer* PeerBlockedNotify::release_peer() {
  // @@protoc_insertion_point(field_release:zproto.PeerBlockedNotify.peer)
  
  ::zproto::Peer* temp = peer_;
  peer_ = NULL;
  return temp;
}
inline ::zproto::Peer* PeerBlockedNotify::mutable_peer() {
  
  if (peer_ == NULL) {
    peer_ = new ::zproto::Peer;
  }
  // @@protoc_insertion_point(field_mutable:zproto.PeerBlockedNotify.peer)
  return peer_;
}
inline void PeerBlockedNotify::set_allocated_peer(::zproto::Peer* peer) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(peer_);
  }
  if (peer) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      peer = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, peer, submessage_arena);
    }
    
  } else {
    
  }
  peer_ = peer;
  // @@protoc_insertion_point(field_set_allocated:zproto.PeerBlockedNotify.peer)
}

// -------------------------------------------------------------------

// PeerUnblockedNotify

// .zproto.Peer peer = 1;
inline bool PeerUnblockedNotify::has_peer() const {
  return this != internal_default_instance() && peer_ != NULL;
}
inline const ::zproto::Peer& PeerUnblockedNotify::peer() const {
  const ::zproto::Peer* p = peer_;
  // @@protoc_insertion_point(field_get:zproto.PeerUnblockedNotify.peer)
  return p != NULL ? *p : *reinterpret_cast<const ::zproto::Peer*>(
      &::zproto::_Peer_default_instance_);
}
inline ::zproto::Peer* PeerUnblockedNotify::release_peer() {
  // @@protoc_insertion_point(field_release:zproto.PeerUnblockedNotify.peer)
  
  ::zproto::Peer* temp = peer_;
  peer_ = NULL;
  return temp;
}
inline ::zproto::Peer* PeerUnblockedNotify::mutable_peer() {
  
  if (peer_ == NULL) {
    peer_ = new ::zproto::Peer;
  }
  // @@protoc_insertion_point(field_mutable:zproto.PeerUnblockedNotify.peer)
  return peer_;
}
inline void PeerUnblockedNotify::set_allocated_peer(::zproto::Peer* peer) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(peer_);
  }
  if (peer) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      peer = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, peer, submessage_arena);
    }
    
  } else {
    
  }
  peer_ = peer;
  // @@protoc_insertion_point(field_set_allocated:zproto.PeerUnblockedNotify.peer)
}

// -------------------------------------------------------------------

// PeerTopedNotify

// .zproto.Peer peer = 1;
inline bool PeerTopedNotify::has_peer() const {
  return this != internal_default_instance() && peer_ != NULL;
}
inline const ::zproto::Peer& PeerTopedNotify::peer() const {
  const ::zproto::Peer* p = peer_;
  // @@protoc_insertion_point(field_get:zproto.PeerTopedNotify.peer)
  return p != NULL ? *p : *reinterpret_cast<const ::zproto::Peer*>(
      &::zproto::_Peer_default_instance_);
}
inline ::zproto::Peer* PeerTopedNotify::release_peer() {
  // @@protoc_insertion_point(field_release:zproto.PeerTopedNotify.peer)
  
  ::zproto::Peer* temp = peer_;
  peer_ = NULL;
  return temp;
}
inline ::zproto::Peer* PeerTopedNotify::mutable_peer() {
  
  if (peer_ == NULL) {
    peer_ = new ::zproto::Peer;
  }
  // @@protoc_insertion_point(field_mutable:zproto.PeerTopedNotify.peer)
  return peer_;
}
inline void PeerTopedNotify::set_allocated_peer(::zproto::Peer* peer) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(peer_);
  }
  if (peer) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      peer = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, peer, submessage_arena);
    }
    
  } else {
    
  }
  peer_ = peer;
  // @@protoc_insertion_point(field_set_allocated:zproto.PeerTopedNotify.peer)
}

// -------------------------------------------------------------------

// PeerUntopedNotify

// .zproto.Peer peer = 1;
inline bool PeerUntopedNotify::has_peer() const {
  return this != internal_default_instance() && peer_ != NULL;
}
inline const ::zproto::Peer& PeerUntopedNotify::peer() const {
  const ::zproto::Peer* p = peer_;
  // @@protoc_insertion_point(field_get:zproto.PeerUntopedNotify.peer)
  return p != NULL ? *p : *reinterpret_cast<const ::zproto::Peer*>(
      &::zproto::_Peer_default_instance_);
}
inline ::zproto::Peer* PeerUntopedNotify::release_peer() {
  // @@protoc_insertion_point(field_release:zproto.PeerUntopedNotify.peer)
  
  ::zproto::Peer* temp = peer_;
  peer_ = NULL;
  return temp;
}
inline ::zproto::Peer* PeerUntopedNotify::mutable_peer() {
  
  if (peer_ == NULL) {
    peer_ = new ::zproto::Peer;
  }
  // @@protoc_insertion_point(field_mutable:zproto.PeerUntopedNotify.peer)
  return peer_;
}
inline void PeerUntopedNotify::set_allocated_peer(::zproto::Peer* peer) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(peer_);
  }
  if (peer) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      peer = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, peer, submessage_arena);
    }
    
  } else {
    
  }
  peer_ = peer;
  // @@protoc_insertion_point(field_set_allocated:zproto.PeerUntopedNotify.peer)
}

// -------------------------------------------------------------------

// PeerDndedNotify

// .zproto.Peer peer = 1;
inline bool PeerDndedNotify::has_peer() const {
  return this != internal_default_instance() && peer_ != NULL;
}
inline const ::zproto::Peer& PeerDndedNotify::peer() const {
  const ::zproto::Peer* p = peer_;
  // @@protoc_insertion_point(field_get:zproto.PeerDndedNotify.peer)
  return p != NULL ? *p : *reinterpret_cast<const ::zproto::Peer*>(
      &::zproto::_Peer_default_instance_);
}
inline ::zproto::Peer* PeerDndedNotify::release_peer() {
  // @@protoc_insertion_point(field_release:zproto.PeerDndedNotify.peer)
  
  ::zproto::Peer* temp = peer_;
  peer_ = NULL;
  return temp;
}
inline ::zproto::Peer* PeerDndedNotify::mutable_peer() {
  
  if (peer_ == NULL) {
    peer_ = new ::zproto::Peer;
  }
  // @@protoc_insertion_point(field_mutable:zproto.PeerDndedNotify.peer)
  return peer_;
}
inline void PeerDndedNotify::set_allocated_peer(::zproto::Peer* peer) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(peer_);
  }
  if (peer) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      peer = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, peer, submessage_arena);
    }
    
  } else {
    
  }
  peer_ = peer;
  // @@protoc_insertion_point(field_set_allocated:zproto.PeerDndedNotify.peer)
}

// -------------------------------------------------------------------

// PeerUndndedNotify

// .zproto.Peer peer = 1;
inline bool PeerUndndedNotify::has_peer() const {
  return this != internal_default_instance() && peer_ != NULL;
}
inline const ::zproto::Peer& PeerUndndedNotify::peer() const {
  const ::zproto::Peer* p = peer_;
  // @@protoc_insertion_point(field_get:zproto.PeerUndndedNotify.peer)
  return p != NULL ? *p : *reinterpret_cast<const ::zproto::Peer*>(
      &::zproto::_Peer_default_instance_);
}
inline ::zproto::Peer* PeerUndndedNotify::release_peer() {
  // @@protoc_insertion_point(field_release:zproto.PeerUndndedNotify.peer)
  
  ::zproto::Peer* temp = peer_;
  peer_ = NULL;
  return temp;
}
inline ::zproto::Peer* PeerUndndedNotify::mutable_peer() {
  
  if (peer_ == NULL) {
    peer_ = new ::zproto::Peer;
  }
  // @@protoc_insertion_point(field_mutable:zproto.PeerUndndedNotify.peer)
  return peer_;
}
inline void PeerUndndedNotify::set_allocated_peer(::zproto::Peer* peer) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(peer_);
  }
  if (peer) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      peer = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, peer, submessage_arena);
    }
    
  } else {
    
  }
  peer_ = peer;
  // @@protoc_insertion_point(field_set_allocated:zproto.PeerUndndedNotify.peer)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace zproto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_dialogs_2eproto__INCLUDED
