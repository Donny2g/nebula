// Code generated by protoc-gen-go. DO NOT EDIT.
// source: messages.proto

package zproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type VoidRsp struct {
}

func (m *VoidRsp) Reset()                    { *m = VoidRsp{} }
func (m *VoidRsp) String() string            { return proto.CompactTextString(m) }
func (*VoidRsp) ProtoMessage()               {}
func (*VoidRsp) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{0} }

// 发聊天消息
// SendMessageReq --> SeqDateRsp
// SEND_MESSAGE_REQ = 0xff09;
type SendMessageReq struct {
	MessageData *MessageContainer `protobuf:"bytes,1,opt,name=message_data,json=messageData" json:"message_data,omitempty"`
}

func (m *SendMessageReq) Reset()                    { *m = SendMessageReq{} }
func (m *SendMessageReq) String() string            { return proto.CompactTextString(m) }
func (*SendMessageReq) ProtoMessage()               {}
func (*SendMessageReq) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{1} }

func (m *SendMessageReq) GetMessageData() *MessageContainer {
	if m != nil {
		return m.MessageData
	}
	return nil
}

// 发送聊天消息响应
// SEND_MESSAGE_RSP = 0xff0a;
type SeqDateRsp struct {
	Seq     uint64 `protobuf:"varint,1,opt,name=seq" json:"seq,omitempty"`
	Created uint64 `protobuf:"varint,2,opt,name=created" json:"created,omitempty"`
}

func (m *SeqDateRsp) Reset()                    { *m = SeqDateRsp{} }
func (m *SeqDateRsp) String() string            { return proto.CompactTextString(m) }
func (*SeqDateRsp) ProtoMessage()               {}
func (*SeqDateRsp) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{2} }

func (m *SeqDateRsp) GetSeq() uint64 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *SeqDateRsp) GetCreated() uint64 {
	if m != nil {
		return m.Created
	}
	return 0
}

// 转发给PushServer
// ForwardMessageReq --> VoidRsp
type ForwardMessageReq struct {
	MessageData    *MessageContainer `protobuf:"bytes,1,opt,name=message_data,json=messageData" json:"message_data,omitempty"`
	NotSendConnIds []uint64          `protobuf:"varint,2,rep,packed,name=not_send_conn_ids,json=notSendConnIds" json:"not_send_conn_ids,omitempty"`
	MyConnId       uint64            `protobuf:"varint,3,opt,name=my_conn_id,json=myConnId" json:"my_conn_id,omitempty"`
}

func (m *ForwardMessageReq) Reset()                    { *m = ForwardMessageReq{} }
func (m *ForwardMessageReq) String() string            { return proto.CompactTextString(m) }
func (*ForwardMessageReq) ProtoMessage()               {}
func (*ForwardMessageReq) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{3} }

func (m *ForwardMessageReq) GetMessageData() *MessageContainer {
	if m != nil {
		return m.MessageData
	}
	return nil
}

func (m *ForwardMessageReq) GetNotSendConnIds() []uint64 {
	if m != nil {
		return m.NotSendConnIds
	}
	return nil
}

func (m *ForwardMessageReq) GetMyConnId() uint64 {
	if m != nil {
		return m.MyConnId
	}
	return 0
}

// 通知客户端有消息到达
// MessageNotify --> MessageAck
type MessageNotify struct {
}

func (m *MessageNotify) Reset()                    { *m = MessageNotify{} }
func (m *MessageNotify) String() string            { return proto.CompactTextString(m) }
func (*MessageNotify) ProtoMessage()               {}
func (*MessageNotify) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{4} }

// 通知客户端有消息到达
// MessageDataNotify --> 客户端会回Ack
type MessageDataNotify struct {
	MessageData *MessageContainer `protobuf:"bytes,1,opt,name=message_data,json=messageData" json:"message_data,omitempty"`
}

func (m *MessageDataNotify) Reset()                    { *m = MessageDataNotify{} }
func (m *MessageDataNotify) String() string            { return proto.CompactTextString(m) }
func (*MessageDataNotify) ProtoMessage()               {}
func (*MessageDataNotify) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{5} }

func (m *MessageDataNotify) GetMessageData() *MessageContainer {
	if m != nil {
		return m.MessageData
	}
	return nil
}

// 请求同步消息
type MessageSyncReq struct {
	ReceivedMaxSeq uint64 `protobuf:"varint,1,opt,name=received_max_seq,json=receivedMaxSeq" json:"received_max_seq,omitempty"`
}

func (m *MessageSyncReq) Reset()                    { *m = MessageSyncReq{} }
func (m *MessageSyncReq) String() string            { return proto.CompactTextString(m) }
func (*MessageSyncReq) ProtoMessage()               {}
func (*MessageSyncReq) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{6} }

func (m *MessageSyncReq) GetReceivedMaxSeq() uint64 {
	if m != nil {
		return m.ReceivedMaxSeq
	}
	return 0
}

// 通知客户端有消息到达
// 可以带多条消息
type MessageSyncRsp struct {
	MessageData []*MessageContainer `protobuf:"bytes,1,rep,name=message_data,json=messageData" json:"message_data,omitempty"`
}

func (m *MessageSyncRsp) Reset()                    { *m = MessageSyncRsp{} }
func (m *MessageSyncRsp) String() string            { return proto.CompactTextString(m) }
func (*MessageSyncRsp) ProtoMessage()               {}
func (*MessageSyncRsp) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{7} }

func (m *MessageSyncRsp) GetMessageData() []*MessageContainer {
	if m != nil {
		return m.MessageData
	}
	return nil
}

// 消息已读
// MessageReadReq --> VoidRsp
type MessageReadReq struct {
	Peer       *Peer  `protobuf:"bytes,1,opt,name=peer" json:"peer,omitempty"`
	ReadMaxSeq uint64 `protobuf:"varint,2,opt,name=read_max_seq,json=readMaxSeq" json:"read_max_seq,omitempty"`
}

func (m *MessageReadReq) Reset()                    { *m = MessageReadReq{} }
func (m *MessageReadReq) String() string            { return proto.CompactTextString(m) }
func (*MessageReadReq) ProtoMessage()               {}
func (*MessageReadReq) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{8} }

func (m *MessageReadReq) GetPeer() *Peer {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *MessageReadReq) GetReadMaxSeq() uint64 {
	if m != nil {
		return m.ReadMaxSeq
	}
	return 0
}

// Loading history of chat
// LoadHistoryReq --> LoadHistoryRsp
type LoadHistoryMessageReq struct {
	// int32 COMMAND_ID = 118;
	Peer     *Peer                   `protobuf:"bytes,1,opt,name=peer" json:"peer,omitempty"`
	Date     uint32                  `protobuf:"varint,2,opt,name=date" json:"date,omitempty"`
	LoadMode EnumHelper_ListLoadMode `protobuf:"varint,3,opt,name=load_mode,json=loadMode,enum=zproto.EnumHelper_ListLoadMode" json:"load_mode,omitempty"`
	Limit    uint32                  `protobuf:"varint,4,opt,name=limit" json:"limit,omitempty"`
}

func (m *LoadHistoryMessageReq) Reset()                    { *m = LoadHistoryMessageReq{} }
func (m *LoadHistoryMessageReq) String() string            { return proto.CompactTextString(m) }
func (*LoadHistoryMessageReq) ProtoMessage()               {}
func (*LoadHistoryMessageReq) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{9} }

func (m *LoadHistoryMessageReq) GetPeer() *Peer {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *LoadHistoryMessageReq) GetDate() uint32 {
	if m != nil {
		return m.Date
	}
	return 0
}

func (m *LoadHistoryMessageReq) GetLoadMode() EnumHelper_ListLoadMode {
	if m != nil {
		return m.LoadMode
	}
	return EnumHelper_ListLoadMode_NONE
}

func (m *LoadHistoryMessageReq) GetLimit() uint32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

// Loaded history
type LoadHistoryMessageRsp struct {
	History []*MessageContainer `protobuf:"bytes,1,rep,name=history" json:"history,omitempty"`
}

func (m *LoadHistoryMessageRsp) Reset()                    { *m = LoadHistoryMessageRsp{} }
func (m *LoadHistoryMessageRsp) String() string            { return proto.CompactTextString(m) }
func (*LoadHistoryMessageRsp) ProtoMessage()               {}
func (*LoadHistoryMessageRsp) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{10} }

func (m *LoadHistoryMessageRsp) GetHistory() []*MessageContainer {
	if m != nil {
		return m.History
	}
	return nil
}

// ///////////////////////////////////////////////////////////////////////////////
// 会话列表协议设计说明（会话驱动）:
//  正常使用不需要用到这几条协议，因为nebula-im的一个设计原则是消息驱动，
//  但为了支持任何终端任何时候的历史漫游，也还需要支持会话驱动。
//
//
// 已有账号换了个手机，第一次进入时要拉取所有会话信息,分成如下几个步骤:
// 1. 拉首屏, 按时间降序, date为uint64最大值
// 2. 如果有必要, 拉取全部会话, 此时远到近拉, 第一次date为0,
//    以后按从小到大的, 一旦ConversationID碰撞,则认为全部接收完毕
//
// 拉取会话列表
// LoadDialogsReq --> LoadDialogsRsp
type LoadDialogsReq struct {
	Date     uint64                  `protobuf:"varint,1,opt,name=date" json:"date,omitempty"`
	LoadMode EnumHelper_ListLoadMode `protobuf:"varint,2,opt,name=load_mode,json=loadMode,enum=zproto.EnumHelper_ListLoadMode" json:"load_mode,omitempty"`
	Limit    uint32                  `protobuf:"varint,3,opt,name=limit" json:"limit,omitempty"`
}

func (m *LoadDialogsReq) Reset()                    { *m = LoadDialogsReq{} }
func (m *LoadDialogsReq) String() string            { return proto.CompactTextString(m) }
func (*LoadDialogsReq) ProtoMessage()               {}
func (*LoadDialogsReq) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{11} }

func (m *LoadDialogsReq) GetDate() uint64 {
	if m != nil {
		return m.Date
	}
	return 0
}

func (m *LoadDialogsReq) GetLoadMode() EnumHelper_ListLoadMode {
	if m != nil {
		return m.LoadMode
	}
	return EnumHelper_ListLoadMode_NONE
}

func (m *LoadDialogsReq) GetLimit() uint32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

// Loaded dialogs
type LoadDialogsRsp struct {
	Dialogs []*Dialog `protobuf:"bytes,1,rep,name=dialogs" json:"dialogs,omitempty"`
}

func (m *LoadDialogsRsp) Reset()                    { *m = LoadDialogsRsp{} }
func (m *LoadDialogsRsp) String() string            { return proto.CompactTextString(m) }
func (*LoadDialogsRsp) ProtoMessage()               {}
func (*LoadDialogsRsp) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{12} }

func (m *LoadDialogsRsp) GetDialogs() []*Dialog {
	if m != nil {
		return m.Dialogs
	}
	return nil
}

func init() {
	proto.RegisterType((*VoidRsp)(nil), "zproto.VoidRsp")
	proto.RegisterType((*SendMessageReq)(nil), "zproto.SendMessageReq")
	proto.RegisterType((*SeqDateRsp)(nil), "zproto.SeqDateRsp")
	proto.RegisterType((*ForwardMessageReq)(nil), "zproto.ForwardMessageReq")
	proto.RegisterType((*MessageNotify)(nil), "zproto.MessageNotify")
	proto.RegisterType((*MessageDataNotify)(nil), "zproto.MessageDataNotify")
	proto.RegisterType((*MessageSyncReq)(nil), "zproto.MessageSyncReq")
	proto.RegisterType((*MessageSyncRsp)(nil), "zproto.MessageSyncRsp")
	proto.RegisterType((*MessageReadReq)(nil), "zproto.MessageReadReq")
	proto.RegisterType((*LoadHistoryMessageReq)(nil), "zproto.LoadHistoryMessageReq")
	proto.RegisterType((*LoadHistoryMessageRsp)(nil), "zproto.LoadHistoryMessageRsp")
	proto.RegisterType((*LoadDialogsReq)(nil), "zproto.LoadDialogsReq")
	proto.RegisterType((*LoadDialogsRsp)(nil), "zproto.LoadDialogsRsp")
}

func init() { proto.RegisterFile("messages.proto", fileDescriptor5) }

var fileDescriptor5 = []byte{
	// 504 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x52, 0x4d, 0x6f, 0x13, 0x31,
	0x10, 0x55, 0x3e, 0x48, 0xda, 0x49, 0xba, 0x34, 0x16, 0x88, 0x55, 0x85, 0x44, 0xb4, 0x5c, 0xc2,
	0x65, 0x0f, 0xe1, 0x82, 0x0a, 0xa7, 0x36, 0xa0, 0x20, 0x1a, 0x14, 0x39, 0x88, 0x03, 0x97, 0x95,
	0xbb, 0x1e, 0x52, 0x4b, 0x59, 0x7b, 0x63, 0x1b, 0x48, 0xfa, 0x4f, 0x38, 0xf2, 0x4f, 0x91, 0x77,
	0x6d, 0x12, 0xa4, 0x48, 0x45, 0xc0, 0x69, 0x3d, 0xcf, 0xcf, 0x6f, 0xde, 0x9b, 0x59, 0x88, 0x0a,
	0x34, 0x86, 0x2d, 0xd1, 0xa4, 0xa5, 0x56, 0x56, 0x91, 0xce, 0x6d, 0xf5, 0x3d, 0xeb, 0x5d, 0x33,
	0x13, 0xc0, 0xb3, 0x5e, 0x89, 0xa8, 0x7d, 0x91, 0x1c, 0x43, 0xf7, 0xa3, 0x12, 0x9c, 0x9a, 0x32,
	0x99, 0x41, 0xb4, 0x40, 0xc9, 0x67, 0xb5, 0x04, 0xc5, 0x35, 0x79, 0x09, 0x7d, 0x2f, 0x98, 0x71,
	0x66, 0x59, 0xdc, 0x18, 0x36, 0x46, 0xbd, 0x71, 0x9c, 0xd6, 0xaa, 0xa9, 0x67, 0x5e, 0x2a, 0x69,
	0x99, 0x90, 0xa8, 0x69, 0xcf, 0xb3, 0x27, 0xcc, 0xb2, 0xe4, 0x05, 0xc0, 0x02, 0xd7, 0x13, 0x66,
	0x91, 0x9a, 0x92, 0x9c, 0x42, 0xcb, 0xe0, 0xba, 0x52, 0x68, 0x53, 0x77, 0x24, 0x31, 0x74, 0x73,
	0x8d, 0xcc, 0x22, 0x8f, 0x9b, 0x15, 0x1a, 0xca, 0xe4, 0x7b, 0x03, 0x06, 0x6f, 0x94, 0xfe, 0xc6,
	0xf4, 0xff, 0x32, 0x43, 0x9e, 0xc1, 0x40, 0x2a, 0x9b, 0x19, 0x94, 0x3c, 0xcb, 0x95, 0x94, 0x99,
	0xe0, 0x26, 0x6e, 0x0e, 0x5b, 0xa3, 0x36, 0x8d, 0xa4, 0xb2, 0x2e, 0xf7, 0xa5, 0x92, 0xf2, 0x2d,
	0x37, 0xe4, 0x31, 0x40, 0xb1, 0x0d, 0xa4, 0xb8, 0x55, 0x59, 0x3b, 0x2a, 0xb6, 0xf5, 0x75, 0x72,
	0x1f, 0x4e, 0x7c, 0xa7, 0xf7, 0xca, 0x8a, 0xcf, 0xdb, 0x64, 0x0e, 0x83, 0xd9, 0xae, 0x51, 0x0d,
	0xfe, 0xdb, 0xe0, 0xce, 0x21, 0xf2, 0x84, 0xc5, 0x56, 0xe6, 0x2e, 0xfa, 0x08, 0x4e, 0x35, 0xe6,
	0x28, 0xbe, 0x22, 0xcf, 0x0a, 0xb6, 0xc9, 0x76, 0x93, 0x8c, 0x02, 0x3e, 0x63, 0x9b, 0x05, 0xae,
	0xdd, 0x0e, 0xf7, 0xdf, 0x9a, 0xf2, 0x80, 0x95, 0xd6, 0x9f, 0x5b, 0xf9, 0xf0, 0x4b, 0x8e, 0x22,
	0xe3, 0xce, 0xca, 0x10, 0xda, 0xee, 0xf7, 0xf1, 0x89, 0xfa, 0x41, 0x66, 0x8e, 0xa8, 0x69, 0x75,
	0x43, 0x86, 0xd0, 0xd7, 0xc8, 0x76, 0x46, 0xeb, 0xe5, 0x82, 0xc3, 0xbc, 0xc9, 0x1f, 0x0d, 0x78,
	0x78, 0xa5, 0x18, 0x9f, 0x0a, 0x63, 0x95, 0xde, 0xee, 0xed, 0xf8, 0x6e, 0x75, 0x02, 0x6d, 0xce,
	0x2c, 0x56, 0xaa, 0x27, 0xb4, 0x3a, 0x93, 0x57, 0x70, 0xbc, 0x52, 0xae, 0xa3, 0xe2, 0x58, 0x2d,
	0x2c, 0x1a, 0x3f, 0x09, 0x4f, 0x5f, 0xcb, 0x2f, 0xc5, 0x14, 0x57, 0x25, 0xea, 0xf4, 0x4a, 0x18,
	0xeb, 0xda, 0xce, 0x14, 0x47, 0x7a, 0xb4, 0xf2, 0x27, 0xf2, 0x00, 0xee, 0xad, 0x44, 0x21, 0x6c,
	0xdc, 0xae, 0x24, 0xeb, 0x22, 0x79, 0x77, 0xd0, 0xa2, 0x29, 0xc9, 0x18, 0xba, 0x37, 0x35, 0x78,
	0xe7, 0x28, 0x03, 0x31, 0xd9, 0x40, 0xe4, 0xc4, 0x26, 0x82, 0xad, 0xd4, 0xd2, 0xb8, 0xa0, 0x21,
	0x46, 0xbd, 0xc5, 0x03, 0x31, 0x9a, 0x7f, 0x1d, 0xa3, 0xb5, 0x1f, 0xe3, 0xfc, 0xf7, 0xce, 0xa6,
	0x24, 0x23, 0xe8, 0xf2, 0xba, 0xf2, 0xfe, 0xa3, 0xd0, 0xa3, 0x26, 0xd1, 0x70, 0x7d, 0xf1, 0x14,
	0x1e, 0xe5, 0xaa, 0x48, 0x6f, 0xf3, 0x1b, 0x66, 0x53, 0x94, 0x4b, 0x21, 0xd1, 0x53, 0x2f, 0x3a,
	0x9f, 0xe6, 0xee, 0x3b, 0x6d, 0x5e, 0x77, 0x2a, 0xe0, 0xf9, 0xcf, 0x00, 0x00, 0x00, 0xff, 0xff,
	0x53, 0x0a, 0xe8, 0xc0, 0x7a, 0x04, 0x00, 0x00,
}
